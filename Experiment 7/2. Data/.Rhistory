data_processed <- data_demographics_and_methods %>%
full_join(data_self_reports, by ='subject') %>%
full_join(data_iat_D2_scores, by='subject') %>%
full_join(data_exploratory_questions, by ='subject') %>%
full_join(data_iat_completeness, by='subject') %>%
full_join(data_iat_performance, by='subject')
# Add in numeric ids for participants
unique_ids <- data_processed %>%
distinct(subject) %>%
rownames_to_column(var = "numeric_id") %>%
mutate(numeric_id = as.numeric(as.character(numeric_id)))
data_processed <- data_processed %>%
full_join(unique_ids, by = "subject")
# Order the columns for subsequent analyses
names(data_processed)
data_processed <- data_processed %>%
mutate(experiment = current_experiment_number) %>%
select(numeric_id,
#subject,
experiment,
age,
gender,
gender_self_describe,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
pos_neg,
good_bad,
like_dislike,
self_reported_rating,
IAT_D2_score,
intentions_q1,
intentions_q2,
intentions_q3,
behavioral_intentions,
memory_of_video_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
deepfake_video_check_1,
deepfake_video_check_2,
deepfake_concept_check_1,
deepfake_concept_check_2,
issues_with_study)
# Ensures that the processed data folder exists
dir.create("processed")
# write to disk
write_csv(data_processed, "processed/data_processed.csv")
data <- read_csv("processed/data_processed.csv")
View(data_iat_D2_scores)
# dependencies -----
library(rstatix)
library(datarium)
library(tidyverse)
library(ggthemes)
library(knitr)
library(kableExtra)
library(broom)
library(effsize)
library(BayesFactor)
library(metafor)
library(ez)
library(schoRsch)
library(nnet)
library(epitools)
library(writexl)
library(readxl)
options(knitr.kable.NA = "/")
# Ensures that the processed data folder exists
dir.create("models")
dir.create("results")
# functions -----
# round p value using apa format
apa_p_value <- function(p){
p_formatted <- ifelse(p >= 0.0001, paste("=", round(p, 4)),
ifelse(p < 0.0001, "< .0001", NA))
p_formatted <- gsub(pattern = "0.", replacement = ".", x = p_formatted, fixed = TRUE)
p_formatted
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_cohens_d <- function(data){
require(effsize)
fit <- effsize::cohen.d(DV ~ IV, data = data)
results <- tibble(cohens_d = fit$estimate,
cohens_d_ci_lower = fit$conf.int["lower"],
cohens_d_ci_upper = fit$conf.int["upper"])
return(results)
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_ttest_bf <- function(data){
require(BayesFactor)
fit <- data %>%
ttestBF(formula = DV ~ IV, data = .)
results <- data.frame(bf10 = extractBF(fit)$bf)
return(results)
}
# full analysis workflow
# NB workflow returns mean_reference and mean_comparison, where reference is the first factor level and comparison is the next highest level.
analysis_workflow <- function(data){
# frequentist t test
results_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(broom::tidy(t.test(DV ~ IV, data = .))) %>%
ungroup() %>%
rename(t = statistic,
df = parameter,
p = p.value,
mean_reference = estimate1,
mean_comaprison = estimate2)
# cohens d
results_cohens_d <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_cohens_d(data = .)) %>%
ungroup()
# BF t test
results_bf_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_ttest_bf(data = .)) %>%
ungroup()
# combine
results <-
full_join(results_t_test,
results_cohens_d,
by = c("experiment", "DV_type")) %>%
full_join(results_bf_t_test,
by = c("experiment", "DV_type")) %>%
select(experiment, DV_type,
mean_reference, mean_comaprison,
t, df, p, cohens_d, cohens_d_ci_lower, cohens_d_ci_upper, bf10) %>%
mutate(reportable_result = paste0("M = ", round(mean_reference, 2), ", M = ", round(mean_comaprison, 2), ", t(", round(df, 2), ") = ", round(t, 2), ", p ", apa_p_value(p), ", d = ", round(cohens_d, 2), ", 95% CI [", round(cohens_d_ci_lower, 2), ", ", round(cohens_d_ci_upper, 2), "], BF10 = ", round(bf10, 1)))
return(results)
}
OR_to_d <- function(OR){
log(OR)*(sqrt(3)/pi)
}
# DATA EXCLUSIONS
# full data
data_processed <-
read_csv("C:/Users/Sean/Desktop/git/DF-Impression-Formation--Video-and-audio-/Experiment 7/2. Data/processed/data_processed.csv")%>%
# set factor levels for experimental condition (pos vs. neg video) and video type (genuine vs. deepfaked)
mutate(experiment_condition = fct_relevel(experiment_condition,
"positive video",
"negative video")) %>%
mutate(video_type = fct_relevel(video_type,
"genuine video",
"deepfake video")) %>%
# create an exclusion variable for IAT data
mutate(exclude_iat = ifelse(complete_iat_data == "complete" & passed_iat_performance == TRUE,
FALSE, TRUE),
# if exclude variable is missing, then exclude
exclude_iat = ifelse(is.na(exclude_iat), TRUE, exclude_iat)) %>%
# create exclusion variable for missing exploratory question data
mutate(exclude_exploratory = ifelse(is.na(memory_of_video_content), TRUE,
ifelse(is.na(diagnosticity_question), TRUE,
ifelse(is.na(demand), TRUE,
ifelse(is.na(reactance), TRUE,
ifelse(is.na(hypothesis_awareness), TRUE,
ifelse(is.na(influence_awareness), TRUE,
ifelse(is.na(deepfake_video_check_1), TRUE,
ifelse(is.na(deepfake_video_check_2), TRUE, FALSE))))))))) %>%
#create compound exclusion criteria
mutate(exclude = exclude_iat + exclude_exploratory)
# remove missing data
data_processed_after_exclusions <- data_processed %>%
filter(exclude == 0)
# Write file to disk for hand scoring of open ended questions
write_xlsx(data_processed_after_exclusions, "results/data_processed_after_exclusions.xlsx")
# Import file after hand scoring of open ended questions
data_processed_after_hand_scoring <- read_xlsx("results/Data_Cleaned_Recoded.xlsx")
View(data_processed_after_exclusions)
# Import file after hand scoring of open ended questions
data_processed_after_hand_scoring <- read_xlsx("results/Data_Cleaned_Recoded.xlsx")
# DATA TRANSFORMATIONS (ordered alphabetically)
# RECODE DEMAND: responses on the demand variable assigned a value of 0 (No Demand) or 1 (Demand)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demand_recoded = case_when(grepl("No", demand) ~ 0,
grepl("I", demand) ~ 0,
grepl("Demand", demand) ~ 1))
# RECODE DIAGNOSTICITY: responses on the diagnostic variable are assigned a value from 0 (Not Diagnostic) to 3 (Strongly Diagnostic)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(diagnosticity_question_recoded = case_when(grepl("Not", diagnosticity_question) ~ 0,
grepl("Slight", diagnosticity_question) ~ 1,
grepl("Moderate", diagnosticity_question) ~ 2,
grepl("Strong", diagnosticity_question) ~ 3))
# RECODE EVALUATIONS: Create two variables (self-report recoded and IAT recoded). An analytic aim (see sections below) is to compare genuine and deepfaked video in terms of their effect sizes. However, in order to do this, we need to control for the valence of the video themselves (some conditions got positive video whereas others got negative video). So the self-reported rating/IAT score * by -1 for those in the negative video condition. This ensures that the negative and positive video are being compared along the same dimension (strength) rather than valence, and that deepfake and genuine video can be directly compared to one another
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(self_report_recoded = ifelse(experiment_condition == "negative video", self_reported_rating * -1, self_reported_rating),
IAT_recoded = ifelse(experiment_condition == "negative video", IAT_D2_score * -1, IAT_D2_score))
# RECODE EXPLORATORY QUESTION CHECKS: responses on this variable assigned a value of 0 (Not Aware it was a Deepfake) or 1 (Aware it was a Deepfake)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(deepfake_concept_check_recoded = case_when(grepl("Yes", deepfake_concept_check_1) ~ 1,
grepl("No", deepfake_concept_check_2) ~ 0)) %>%
mutate(deepfake_video_check_recoded = case_when(grepl("Yes", deepfake_video_check_1) ~ 1,
grepl("No", deepfake_video_check_1) ~ 0)) %>%
mutate(recognised_video_manipulation_ = case_when(grepl("Yes", recognised_video_manipulation) ~ 1,
grepl("No", recognised_video_manipulation) ~ 0)) %>%
mutate(influence_awareness_recoded_ = case_when(grepl("Yes", influence_awareness_recoded) ~ 1,
grepl("No", influence_awareness_recoded) ~ 0)) %>%
mutate(hypothesis_awareness_recoded_ = case_when(grepl("Yes", hypothesis_awareness_recoded) ~ 1,
grepl("No", hypothesis_awareness_recoded) ~ 0))
# RECODE INTENTIONS: the raw scoring of intentions was 1 (strongly disagree) 2 (disagree) 3 (neutral) 4 (agree) and 5 (strongly agree). I've recoded the scores as follows: -2 (strongly disagree) -1 (disagree) 0 (neutral) 1 (agree) 2 (strongly agree)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(intentions_q1_recoded = case_when((intentions_q1 == 1) ~ -2,
(intentions_q1 == 2) ~ -1,
(intentions_q1 == 3) ~  0,
(intentions_q1 == 4) ~  1,
(intentions_q1 == 5) ~  2)) %>%
mutate(intentions_q2_recoded = case_when((intentions_q2 == 1) ~ -2,
(intentions_q2 == 2) ~ -1,
(intentions_q2 == 3) ~  0,
(intentions_q2 == 4) ~  1,
(intentions_q2 == 5) ~  2)) %>%
mutate(intentions_q3_recoded = case_when((intentions_q3 == 1) ~ -2,
(intentions_q3 == 2) ~ -1,
(intentions_q3 == 3) ~  0,
(intentions_q3 == 4) ~  1,
(intentions_q3 == 5) ~  2)) %>%
mutate(overall_intentions_score = (intentions_q1_recoded + intentions_q2_recoded + intentions_q3_recoded)/3)
# RECODE REACTANCE: responses on the reactance variable assigned a value of 0 (No Reactance) or 1 (Reactance)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(reactance_recoded = case_when(grepl("No", reactance) ~ 0,
grepl("I", reactance) ~ 0,
grepl("React", reactance) ~ 1))
# Order Variables in File for Later Analysis
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demographic_items = "*",
method_items = "*",
evaluative_items = "*",
exploratory_items = "*",
individual_difference_items = "*") %>%
select(numeric_id,
experiment,
demographic_items,
age,
gender,
gender_self_describe,
ethnicity,
ethnicity_self_describe,
method_items,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
exclude_iat,
exclude_exploratory,
exclude,
evaluative_items,
pos_neg,
good_bad,
like_dislike,
intentions_q1,
intentions_q1_recoded,
intentions_q2,
intentions_q2_recoded,
intentions_q3,
intentions_q3_recoded,
self_reported_rating,
self_report_recoded,
IAT_D2_score,
IAT_recoded,
overall_intentions_score,
exploratory_items,
memory_of_video_content,
diagnosticity_question,
diagnosticity_question_recoded,
demand,
demand_recoded,
reactance,
reactance_recoded,
hypothesis_awareness,
hypothesis_awareness_recoded_,
influence_awareness,
influence_awareness_recoded_,
recognised_video_manipulation_,
deepfake_video_check_1,
deepfake_video_check_2,
deepfake_video_check_recoded,
deepfake_concept_check_1,
deepfake_concept_check_2,
deepfake_concept_check_recoded,
issues_with_study)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demographic_items = "*",
method_items = "*",
evaluative_items = "*",
exploratory_items = "*",
individual_difference_items = "*") %>%
select(numeric_id,
experiment,
demographic_items,
age,
gender,
gender_self_describe,
method_items,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
exclude_iat,
exclude_exploratory,
exclude,
evaluative_items,
pos_neg,
good_bad,
like_dislike,
intentions_q1,
intentions_q1_recoded,
intentions_q2,
intentions_q2_recoded,
intentions_q3,
intentions_q3_recoded,
self_reported_rating,
self_report_recoded,
IAT_D2_score,
IAT_recoded,
overall_intentions_score,
exploratory_items,
memory_of_video_content,
diagnosticity_question,
diagnosticity_question_recoded,
demand,
demand_recoded,
reactance,
reactance_recoded,
hypothesis_awareness,
hypothesis_awareness_recoded_,
influence_awareness,
influence_awareness_recoded_,
recognised_video_manipulation_,
deepfake_video_check_1,
deepfake_video_check_2,
deepfake_video_check_recoded,
deepfake_concept_check_1,
deepfake_concept_check_2,
deepfake_concept_check_recoded,
issues_with_study)
# DATA TRANSFORMATIONS (ordered alphabetically)
# RECODE DEMAND: responses on the demand variable assigned a value of 0 (No Demand) or 1 (Demand)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demand_recoded = case_when(grepl("No", demand) ~ 0,
grepl("I", demand) ~ 0,
grepl("Demand", demand) ~ 1))
# RECODE DIAGNOSTICITY: responses on the diagnostic variable are assigned a value from 0 (Not Diagnostic) to 3 (Strongly Diagnostic)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(diagnosticity_question_recoded = case_when(grepl("Not", diagnosticity_question) ~ 0,
grepl("Slight", diagnosticity_question) ~ 1,
grepl("Moderate", diagnosticity_question) ~ 2,
grepl("Strong", diagnosticity_question) ~ 3))
# RECODE EVALUATIONS: Create two variables (self-report recoded and IAT recoded). An analytic aim (see sections below) is to compare genuine and deepfaked video in terms of their effect sizes. However, in order to do this, we need to control for the valence of the video themselves (some conditions got positive video whereas others got negative video). So the self-reported rating/IAT score * by -1 for those in the negative video condition. This ensures that the negative and positive video are being compared along the same dimension (strength) rather than valence, and that deepfake and genuine video can be directly compared to one another
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(self_report_recoded = ifelse(experiment_condition == "negative video", self_reported_rating * -1, self_reported_rating),
IAT_recoded = ifelse(experiment_condition == "negative video", IAT_D2_score * -1, IAT_D2_score))
# RECODE EXPLORATORY QUESTION CHECKS: responses on this variable assigned a value of 0 (Not Aware it was a Deepfake) or 1 (Aware it was a Deepfake)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(deepfake_concept_check_recoded = case_when(grepl("Yes", deepfake_concept_check_1) ~ 1,
grepl("No", deepfake_concept_check_2) ~ 0)) %>%
mutate(deepfake_video_check_recoded = case_when(grepl("Yes", deepfake_video_check_1) ~ 1,
grepl("No", deepfake_video_check_1) ~ 0)) %>%
mutate(recognised_video_manipulation_ = case_when(grepl("Yes", recognised_video_manipulation) ~ 1,
grepl("No", recognised_video_manipulation) ~ 0)) %>%
mutate(influence_awareness_recoded_ = case_when(grepl("Yes", influence_awareness_recoded) ~ 1,
grepl("No", influence_awareness_recoded) ~ 0)) %>%
mutate(hypothesis_awareness_recoded_ = case_when(grepl("Yes", hypothesis_awareness_recoded) ~ 1,
grepl("No", hypothesis_awareness_recoded) ~ 0))
# Import file after hand scoring of open ended questions
data_processed_after_hand_scoring <- read_xlsx("results/Data_Cleaned_Recoded.xlsx")
# DATA TRANSFORMATIONS (ordered alphabetically)
# RECODE DEMAND: responses on the demand variable assigned a value of 0 (No Demand) or 1 (Demand)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demand_recoded = case_when(grepl("No", demand) ~ 0,
grepl("I", demand) ~ 0,
grepl("Demand", demand) ~ 1))
# RECODE DIAGNOSTICITY: responses on the diagnostic variable are assigned a value from 0 (Not Diagnostic) to 3 (Strongly Diagnostic)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(diagnosticity_question_recoded = case_when(grepl("Not", diagnosticity_question) ~ 0,
grepl("Slight", diagnosticity_question) ~ 1,
grepl("Moderate", diagnosticity_question) ~ 2,
grepl("Strong", diagnosticity_question) ~ 3))
# RECODE EVALUATIONS: Create two variables (self-report recoded and IAT recoded). An analytic aim (see sections below) is to compare genuine and deepfaked video in terms of their effect sizes. However, in order to do this, we need to control for the valence of the video themselves (some conditions got positive video whereas others got negative video). So the self-reported rating/IAT score * by -1 for those in the negative video condition. This ensures that the negative and positive video are being compared along the same dimension (strength) rather than valence, and that deepfake and genuine video can be directly compared to one another
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(self_report_recoded = ifelse(experiment_condition == "negative video", self_reported_rating * -1, self_reported_rating),
IAT_recoded = ifelse(experiment_condition == "negative video", IAT_D2_score * -1, IAT_D2_score))
# RECODE EXPLORATORY QUESTION CHECKS: responses on this variable assigned a value of 0 (Not Aware it was a Deepfake) or 1 (Aware it was a Deepfake)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(deepfake_concept_check_recoded = case_when(grepl("Yes", deepfake_concept_check_1) ~ 1,
grepl("No", deepfake_concept_check_2) ~ 0)) %>%
mutate(deepfake_video_check_recoded = case_when(grepl("Yes", deepfake_video_check_1) ~ 1,
grepl("No", deepfake_video_check_1) ~ 0)) %>%
mutate(recognised_video_manipulation_ = case_when(grepl("Yes", recognised_video_manipulation) ~ 1,
grepl("No", recognised_video_manipulation) ~ 0)) %>%
mutate(influence_awareness_recoded_ = case_when(grepl("Yes", influence_awareness_recoded) ~ 1,
grepl("No", influence_awareness_recoded) ~ 0)) %>%
mutate(hypothesis_awareness_recoded_ = case_when(grepl("Yes", hypothesis_awareness_recoded) ~ 1,
grepl("No", hypothesis_awareness_recoded) ~ 0))
# RECODE INTENTIONS: the raw scoring of intentions was 1 (strongly disagree) 2 (disagree) 3 (neutral) 4 (agree) and 5 (strongly agree). I've recoded the scores as follows: -2 (strongly disagree) -1 (disagree) 0 (neutral) 1 (agree) 2 (strongly agree)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(intentions_q1_recoded = case_when((intentions_q1 == 1) ~ -2,
(intentions_q1 == 2) ~ -1,
(intentions_q1 == 3) ~  0,
(intentions_q1 == 4) ~  1,
(intentions_q1 == 5) ~  2)) %>%
mutate(intentions_q2_recoded = case_when((intentions_q2 == 1) ~ -2,
(intentions_q2 == 2) ~ -1,
(intentions_q2 == 3) ~  0,
(intentions_q2 == 4) ~  1,
(intentions_q2 == 5) ~  2)) %>%
mutate(intentions_q3_recoded = case_when((intentions_q3 == 1) ~ -2,
(intentions_q3 == 2) ~ -1,
(intentions_q3 == 3) ~  0,
(intentions_q3 == 4) ~  1,
(intentions_q3 == 5) ~  2)) %>%
mutate(overall_intentions_score = (intentions_q1_recoded + intentions_q2_recoded + intentions_q3_recoded)/3)
# RECODE REACTANCE: responses on the reactance variable assigned a value of 0 (No Reactance) or 1 (Reactance)
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(reactance_recoded = case_when(grepl("No", reactance) ~ 0,
grepl("I", reactance) ~ 0,
grepl("React", reactance) ~ 1))
# Order Variables in File for Later Analysis
data_processed_after_hand_scoring <- data_processed_after_hand_scoring %>%
mutate(demographic_items = "*",
method_items = "*",
evaluative_items = "*",
exploratory_items = "*",
individual_difference_items = "*") %>%
select(numeric_id,
experiment,
demographic_items,
age,
gender,
gender_self_describe,
method_items,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
exclude_iat,
exclude_exploratory,
exclude,
evaluative_items,
pos_neg,
good_bad,
like_dislike,
intentions_q1,
intentions_q1_recoded,
intentions_q2,
intentions_q2_recoded,
intentions_q3,
intentions_q3_recoded,
self_reported_rating,
self_report_recoded,
IAT_D2_score,
IAT_recoded,
overall_intentions_score,
exploratory_items,
memory_of_video_content,
diagnosticity_question,
diagnosticity_question_recoded,
demand,
demand_recoded,
reactance,
reactance_recoded,
hypothesis_awareness,
hypothesis_awareness_recoded_,
influence_awareness,
influence_awareness_recoded_,
recognised_video_manipulation_,
deepfake_video_check_1,
deepfake_video_check_2,
deepfake_video_check_recoded,
deepfake_concept_check_1,
deepfake_concept_check_2,
deepfake_concept_check_recoded,
issues_with_study)
# Write file to disk for hand scoring of open ended questions
write_xlsx(data_processed_after_hand_scoring, "results/data_for_analysis.xlsx")
# Write deepfake only condition subset of data
deepfake_only_data <- data_processed_after_hand_scoring %>%
filter(video_type == "deepfake video") %>%
write_xlsx("results/deepfake_only.xlsx")
# Write genuine only condition subset of data
genuine_only_data <- data_processed_after_hand_scoring %>%
filter(video_type == "genuine video") %>%
write_xlsx("results/genuine_only.xlsx")
data_processed_after_hand_scoring %>%
summarise(n = n(),
age_mean = mean(age, na.rm = TRUE),
age_sd = sd(age, na.rm = TRUE),
excluded_n = sum(exclude > 0),
excluded_percent = (excluded_n / n) *100) %>%
mutate_if(is.numeric, round, digits = 1) %>%
kable(align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
data_processed_after_hand_scoring %>%
count(experiment, gender) %>%
spread(gender, n) %>%
kable(knitr.kable.NA = "/", align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
