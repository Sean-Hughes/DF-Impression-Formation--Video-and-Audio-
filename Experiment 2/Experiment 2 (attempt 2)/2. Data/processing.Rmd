---
title: "Data processing"
author: "Sean Hughes"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes 
    toc_float: yes
---

```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      warning=FALSE)
```

# Functions and Dependencies

```{r}

library(tidyverse)
library(readxl)
library(ggthemes)
library(knitr)
library(kableExtra)
library(IATscores)
library(pacman)
library(RSQLite)
library(jsonlite)
library(janitor)
library(Hmisc)
library(ggplot2)
library(haven)
library(IATscores)

# Used to reduce unique ids to a smaller number
count_unique <- function(x) {
  return(length(unique(x)))
}
information_preserved <- function(x, length) {
  return(
    count_unique(str_sub(x, end=i)) ==
      count_unique(x)
  )
}

# used to extract the JSON data
parseJSON <- function(input) {
  return(input %>%
           fromJSON(flatten=T) %>% {
             # Coerce lists
             if (class(.) == 'list') {
               discard(., is.null) %>%
                 as_tibble()
             } else {
               .
             } } %>%
           # Sanitize names
           janitor::clean_names() %>%
           # Use only strings for now, and re-encode types later
           mutate_all(as.character))
}


```

# Connect to the SQL Database

```{r}

# 'Connect' to database
connection <- dbConnect(
  drv=RSQLite::SQLite(),
  dbname= "raw/Experiment_2_data.sqlite")

# Extract main table
database <- dbGetQuery(
  conn=connection,
  statement='SELECT * FROM labjs')

# Close connection
dbDisconnect(
  conn=connection)

# Discard connection
rm(connection)

```

# Extract Metadata

```{r}

database_meta_data <- map_dfr(database$metadata, fromJSON) %>%
  dplyr::rename(observation = id)

database <- database %>%
  bind_cols(database_meta_data) %>%
  
  # Remove metadata column
  select(-metadata)

# Remove temporary data frame
rm(database_meta_data)

```

# Shorten random id for each participant

```{r}

# Reduce the length of the random id variable to five characters (this is a sufficient length to identify each unique participant)

for (i in 5:36) {
  if (
    information_preserved(database$session, i) &&
    information_preserved(database$observation, i)
  ) {
    break()
  }
}
database <- database %>%
  dplyr::mutate(
    session=str_sub(session, end=i),
    observation=str_sub(observation, end=i))

rm(i, count_unique, information_preserved)

```

# Extract full data from database

```{r}

database_full <- database %>%
  dplyr::filter(payload == 'full') 

if (nrow(database_full) > 0) {
  database_full %>%
    group_by(observation, id) %>%
    do(
      { map_dfr(.$data, parseJSON) } %>%
        bind_rows()
    ) %>%
    ungroup() %>%
    select(-id) -> database_full
}

```

# Extract incremental data from database

```{r}

database %>%
  dplyr::filter(payload %in% c('incremental', 'latest')) %>%
  group_by(observation, id) %>%
  do(
    { map_dfr(.$data, parseJSON) } %>%
      bind_rows()
  ) %>%
  ungroup() %>%
  select(-id) -> database_incremental

gc()

```

# Merge full and incremental datasets

```{r}
##Merge data sets

#For analysis, we'll use the full data sets where available, and incremental data when it is the the only information we have for a user.

raw_data <- database_full %>%
  bind_rows(
    database_incremental %>% 
      filter(!(observation %in% database_full$observation))) %>%
  type_convert()

gc()

# rename the observation column to subject

raw_data <- raw_data %>% 
  rename(subject = observation)

```

# Postprocessing

```{r}
# Ensures that all cells contain the same value even if only a subset of those cells is currently filled

raw_data %>%
  group_by(subject) %>%
  fill(matches('code'), .direction='down') %>%
  fill(matches('code'), .direction='up') %>%
  ungroup() -> raw_data

rm(database, database_full, database_incremental)

# Create  a backup of the data while I am writing the script so I don't have to work with the database which takes a bunch of time

Raw_Data <- raw_data 
```

# Demographics and Method Factors 

```{r}

current_experiment_number <- 2.2

# Select out the demographic and method factor information

data_demographics_and_methods <- raw_data %>% 
  select(subject, 
         prolific_id, 
         age, 
         gender, 
         condition, 
         name) %>%
  
  group_by(subject) %>%
  
  # Remove na values (note: this does not exclude participants)
  
  summarise_all(funs(first(na.omit(.)))) %>% 
  
  # Inspecting the labeling of the IAT blocks and block order in the raw data (see the Lab.js script used to run the study) one sees that the labeling is incorrect. Specifically, the IAT block order in conditions 1-4 was run in the following way [B1, B2, B3, B4, B5, B6, B7]. In this case a positive IAT score would indicate a preference for Chris over Bob and a negative score the opposite. In conditions 5-8 the IAT was run in the following way [B5, B2, B6, B7, B1, B3, B4]. In this case a positive score would indicate a preference for Bob over Chris and a negative score the opposite. To clarify this I have created a new variable (Revised_Exp_Condition) where the correct block order is noted).
  
  mutate(revised_condition = case_when(grepl("C1", condition) ~ "C1. Positive_Video_IAT_First (Con B First)", 
                                       grepl("C2", condition) ~ "C2. Positive_Video_SR_First (Con B First)", 
                                       grepl("C3", condition) ~ "C3. Negative_Video_IAT_First (Incon B First)", 
                                       grepl("C4", condition) ~ "C4. Negative_Video_SR_First (Incon B First)", 
                                       grepl("C5", condition) ~ "C5. Positive_Video_IAT_First (Incon B First)", 
                                       grepl("C6", condition) ~ "C6. Positive_Video_SR_First (Incon B First)", 
                                       grepl("C7", condition) ~ "C7. Negative_Video_IAT_First (Con B First)", 
                                       grepl("C8", condition) ~ "C8. Negative_Video_SR_First (Con B First)",)) %>%
  
  # create separate columns for each method factor 
  
  mutate(revised_condition_number = case_when(grepl("C1", condition) ~ 1, 
                                              grepl("C2", condition) ~ 2, 
                                              grepl("C3", condition) ~ 3, 
                                              grepl("C4", condition) ~ 4, 
                                              grepl("C5", condition) ~ 5, 
                                              grepl("C6", condition) ~ 6, 
                                              grepl("C7", condition) ~ 7, 
                                              grepl("C8", condition) ~ 8,)) %>%
  
  mutate(IAT_block_order = case_when(grepl("Incon B", revised_condition) ~ "Learning Inconsistent block First", 
                                     grepl("Con B", revised_condition) ~ "Learning Consistent block First")) %>% 
  
  mutate(experiment_condition = case_when(grepl("Positive_Video", revised_condition) ~ "Positive Video", 
                                          grepl("Negative_Video", revised_condition) ~ "Negative Video")) %>% 
  
  mutate(task_order = case_when(grepl("IAT_First", revised_condition) ~ "IAT First", 
                                grepl("SR_First", revised_condition) ~ "Ratings First"))

```

# Self-Reported Ratings 

```{r}

# select out the self-reported ratings and the participant id (subject)

data_self_reports <- raw_data %>% 
  
  select(subject, 
         pos_neg, 
         good_bad, 
         like_dislike) %>% 
  
  group_by(subject) %>%
  
  summarise_all(funs(first(na.omit(.)))) %>% 
  # create an average rating score 
  mutate(self_reported_rating = (pos_neg + good_bad + like_dislike)/3) %>% 
  mutate_if(is.numeric, round, digits = 2) 

```

# Exploratory Questions


```{r}

# Select and retain only the exploratory questions and participant id

data_exploratory_questions <- raw_data %>% 
  
  select(subject, 
         memory_of_video_content, 
         diagnosticity_question, 
         demand, 
         reactance, 
         hypothesis_awareness, 
         influence_awareness, 
         issues_with_study) %>% 
  
  group_by(subject) %>%
  
  summarise_all(funs(first(na.omit(.))))

```

# IAT

## Tidying

```{r}

data_iat_input <- raw_data %>%
  
  # Select and retain IAT related variables
  
  select(subject, 
         name, 
         corr,
         sender, 
         sender_id, 
         correct, 
         duration) %>%
  
  # Select out only the data where the stimulus was shown
  
  filter(sender == 'Stimulus') %>% 
  
  # Create a block and Trial column. Do so by renaming values from the 'sender_id' column to terms that the IAT script will work with (e.g., block 1,2,3,4,5,6,7)
  
  separate(sender_id, into = c("temp_1", "temp_2", "temp_3", "block", "trial"), sep = "_") %>%
  
  select(-temp_1, -temp_2, -temp_3) %>% 
  
  # Recode trial numbers so that they begin at 1 and run to 16 or 32
  
  mutate(block = as.numeric(block),
         trial = as.numeric(trial) + 1) %>%
  rename(trial_number = trial) %>%
  
  # Recode the TRUE/FALSE values from the correct column to 1,0 
  
  mutate(Correct = case_when(grepl("TRUE", correct) ~ 1,
                             grepl("FALSE", correct) ~ 0)) %>%
  
  # Bring in the correct (i.e., Revised) Experimental Condition information from the Demographics File
  
  full_join(data_demographics_and_methods, by = 'subject') %>%
  
  # Recode block
  # For participants in Conditions 1-4 the 'sender_id variable' corresponds to the following block order (this can be seen by inspecting the name and corr variables in the raw data):
  
  # _3_0_0   = block 1 (Bob Chris)
  # _5_0_0   = block 2 (Bad Good)
  # _7_0_0   = block 3 (Bob Bad Chris Good)
  # _9_0_0   = block 4 (Bob Bad Chris Good)
  # _11_0_0  = block 5 (Chris Bob)
  # _13_0_0  = block 6 (Chris Bad Bob Good)
  # _15_0_0  = block 7 (Chris Bad Bob Good)

# For participants in Conditions 5-8 the 'sender_id variable' corresponds to the following block order:

# _3_0_0   = block 5 (Chris Bob)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 6 (Chris Bad Bob Good)
# _9_0_0   = block 7 (Chris Bad Bob Good)
# _11_0_0  = block 1 (Bob Chris)
# _13_0_0  = block 3 (Bob Bad Chris Good)
# _15_0_0  = block 4 (Bob Bad Chris Good)

# Create a new variable (Revised block) and update the block numbering so that it is correct: 

mutate(revised_block = ifelse(revised_condition_number %in% c(1, 2, 3, 4), 
                              case_when(block == 3 ~ 1,
                                        block == 5 ~ 2,
                                        block == 7 ~ 3,
                                        block == 9 ~ 4,
                                        block == 11 ~ 5,
                                        block == 13 ~ 6,
                                        block == 15 ~ 7), 
                              ifelse(revised_condition_number %in% c(5, 6, 7, 8), 
                                     case_when(block == 3 ~ 5,
                                               block == 5 ~ 2,
                                               block == 7 ~ 6,
                                               block == 9 ~ 7,
                                               block == 11 ~ 1,
                                               block == 13 ~ 3,
                                               block == 15 ~ 4),NA))) %>%
#Select IAT related data 

select(subject, 
       revised_condition,
       revised_condition_number,
       name = name.x,
       corr,
       trial_number, 
       block, 
       revised_block, 
       correct, 
       duration, 
       IAT_block_order)

# rename columns that IATscores package will use later on
  
data_iat_input <- data_iat_input %>%
  mutate(experiment = current_experiment_number) %>%
  select(subject, 
         trial_number, 
         block = revised_block, 
         correct, 
         latency = duration, 
         IAT_block_order,
         revised_condition,
         revised_condition_number)

# only retain the critical practice and test blocks (i.e., block_number = 3, 4, 6, 7)

data_iat_cleaned <- data_iat_input %>%
  filter(block %in% c(3, 4, 6, 7)) %>%


  # Create a new variable called Block_Type that indicates if a given block is a compatible or incompatible test block and if it is the first or second such block
  
  # Participants in Condition 1, 2, 5, 6 received a positive video. Therefore blocks 3,4 are consistent with the video and blocks 6,7 are inconsistent with the video.
  
  # Participants in Condition 3, 4, 7, 8 received a negative video. Therefore blocks 3,4 are inconsistent with the video and 6,7 are consistent with the video.  
  
  mutate(block_type = ifelse(revised_condition_number %in% c(1, 2, 5, 6), 
                             case_when(block == 3 ~ "compatibletest1",
                                       block == 4 ~ "compatibletest2",
                                       block == 6 ~ "incompatibletest1",
                                       block == 7 ~ "incompatibletest2"), 
                             ifelse(revised_condition_number %in% c(3, 4, 7, 8), 
                                    case_when(block == 3 ~ "incompatibletest1",
                                              block == 4 ~ "incompatibletest2",
                                              block == 6 ~ "compatibletest1",
                                              block == 7 ~ "compatibletest2"),NA)))

```


## Completeness

```{r}

data_iat_completeness <- data_iat_cleaned %>%
  group_by(subject) %>%
  summarise(n = n()) %>%
  mutate(complete_iat_data = case_when(n == 128 ~ "complete", 
                                       n > 128 ~ "excess", 
                                       n < 128 ~"partial")) %>%
  ungroup() %>%
  select(-n)

data_iat_completeness %>%
  distinct(subject, .keep_all = TRUE) %>%
  count(complete_iat_data) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```


## Performance

```{r}

# exclude if total error rate > 30% 
data_iat_accuracy_overall <- data_iat_cleaned %>% 
  group_by(subject) %>% 
  summarise(iat_accuracy_overall = sum(correct)/n()) %>%
  ungroup() %>%
  mutate(passed_iat_accuracy_overall = ifelse(iat_accuracy_overall >= .70, TRUE, FALSE)) %>%
  select(subject, passed_iat_accuracy_overall)

# exclude if error rate on any one block > 40% 
data_iat_accuracy_by_block <- data_iat_cleaned %>% 
  group_by(subject, block) %>% 
  summarise(iat_accuracy_by_block = sum(correct)/n()) %>%
  ungroup() %>%
  mutate(passed_iat_accuracy_by_block = ifelse(iat_accuracy_by_block >= .60, TRUE, FALSE)) %>%
  group_by(subject) %>%
  summarise(passed_iat_accuracy_by_block = as.logical(min(passed_iat_accuracy_by_block))) %>%
  ungroup()

data_iat_fast_responding <- data_iat_cleaned %>% 
  mutate(fast_response = ifelse(latency < 300, 1, 0)) %>%
  group_by(subject) %>% 
  summarise(iat_percent_fast_responses = sum(fast_response)/n()) %>%
  ungroup() %>%
  mutate(passed_iat_percent_fast_responses = ifelse(iat_percent_fast_responses <= .10, TRUE, FALSE)) %>%
  select(subject, passed_iat_percent_fast_responses)

data_iat_performance <- data_iat_accuracy_overall %>%
  full_join(data_iat_accuracy_by_block, by = "subject") %>%
  full_join(data_iat_fast_responding, by = "subject") %>%
  rowwise() %>%
  mutate(passed_iat_performance = as.logical(min(c(passed_iat_accuracy_overall, 
                                                   passed_iat_accuracy_by_block,   
                                                   passed_iat_percent_fast_responses), na.rm = TRUE))) %>%
  ungroup() %>%
  select(subject, passed_iat_performance)

rm(data_iat_accuracy_overall, data_iat_accuracy_by_block, data_iat_fast_responding)

```

## D2 scoring

```{r}

data_iat_D2_scores <- data_iat_cleaned %>%
  # rename and recode to create the input format that the IATscores package requires
  mutate(praccrit = ifelse(block_type == "incompatibletest1" | block_type == "compatibletest1", 
                           "prac", "crit"),
         blockcode = ifelse(block_type == "incompatibletest1" | block_type == "incompatibletest2",
                            "incompatible_block", "compatible_block")) %>%
  select(subject, subject, block, correct, latency, praccrit,  trial_number, block_type) %>%
  mutate(blockcode = ifelse(block %in% c(3, 4), "pair1", 
                            ifelse(block %in% c(6, 7), "pair2", NA)),
         praccrit = ifelse(block %in% c(3, 6), "prac", 
                           ifelse(block %in% c(4, 7), "crit", NA)))  %>%
  filter(!is.na(blockcode)) %>%
  # calculate D2 scores
  # parameters are identical to those the package lists in the D2 wrapper function
  IATscores::RobustScores(IATdata = .,
                          P1 = "fxtrim",  # Trim values < 400ms
                          P2 = "ignore",  # do not trim errors
                          P3 = "dscore",  # calculate d2 scores
                          P4 = "dist",    # distinguish between the prac and test blocks
                          verbose = FALSE,
                          autoremove = FALSE) %>%
  rename(IAT_D2_score = p2112) 

```


## 5. Join the Various Files Together

```{r}

# Join all the files together for analyses

data_processed <- data_demographics_and_methods %>% 
  full_join(data_self_reports, by ='subject') %>%
  full_join(data_exploratory_questions, by ='subject') %>%
  full_join(data_iat_D2_scores, by='subject') %>% 
  full_join(data_iat_completeness, by='subject') %>% 
  full_join(data_iat_performance, by='subject') 

# Add in numeric ids for participants 

unique_ids <- data_processed %>% 
  distinct(subject) %>%
  rownames_to_column(var = "numeric_id") %>%
  mutate(numeric_id = as.numeric(as.character(numeric_id))) 

data_processed <- data_processed %>% 
  full_join(unique_ids, by = "subject") 

# Order the columns for subsequent analyses

data_processed <- data_processed %>% 
  mutate(experiment = current_experiment_number) %>%
  select(numeric_id, 
         #subject, 
         experiment,
         gender, 
         age, 
         revised_condition,
         experiment_condition, 
         task_order, 
         IAT_block_order,
         complete_iat_data,
         passed_iat_performance,
         pos_neg, 
         good_bad,
         like_dislike, 
         self_reported_rating,
         IAT_D2_score,
         memory_of_video_content, 
         diagnosticity_question, 
         demand, 
         reactance, 
         hypothesis_awareness, 
         influence_awareness, 
         issues_with_study)

```

# Combine and write to disk

```{r}

# Ensures that the processed data folder exists
dir.create("processed")

# write to disk
write_csv(data_processed, "processed/data_processed.csv")

data <- read_csv("processed/data_processed.csv")

```


