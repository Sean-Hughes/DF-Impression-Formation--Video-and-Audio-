database_deepfaked_videos <- database_deepfaked_videos %>%
dplyr::mutate(
session=str_sub(session, end=i),
observation=str_sub(observation, end=i))
rm(i, count_unique, information_preserved)
database_deepfaked_videos_full <- database_deepfaked_videos %>%
dplyr::filter(payload == 'full')
if (nrow(database_deepfaked_videos_full) > 0) {
database_deepfaked_videos_full %>%
group_by(observation, id) %>%
do(
{ map_dfr(.$data, parseJSON) } %>%
bind_rows()
) %>%
ungroup() %>%
select(-id) -> database_deepfaked_videos_full
}
database_deepfaked_videos %>%
dplyr::filter(payload %in% c('incremental', 'latest')) %>%
group_by(observation, id) %>%
do(
{ map_dfr(.$data, parseJSON) } %>%
bind_rows()
) %>%
ungroup() %>%
select(-id) -> database_deepfaked_videos_incremental
gc()
##Merge data sets
#For analysis, we'll use the full data sets where available, and incremental data when it is the the only information we have for a user.
raw_data_deepfaked_videos <- database_deepfaked_videos_full %>%
bind_rows(
database_deepfaked_videos_incremental %>%
filter(!(observation %in% database_deepfaked_videos_full$observation))) %>%
type_convert()
gc()
# rename the observation column to subject
raw_data_deepfaked_videos <- raw_data_deepfaked_videos %>%
rename(subject = observation)
# Ensures that all cells contain the same value even if only a subset of those cells is currently filled
raw_data_deepfaked_videos %>%
group_by(subject) %>%
fill(matches('code'), .direction='down') %>%
fill(matches('code'), .direction='up') %>%
ungroup() -> raw_data_deepfaked_videos
rm(database_deepfaked_videos, database_deepfaked_videos_full, database_deepfaked_videos_incremental)
# Create  a backup of the data while I am writing the script so I don't have to work with the database which takes a bunch of time
Raw_Data_deepfake <- raw_data_deepfaked_videos
raw_data_genuine_videos <- raw_data_genuine_videos %>%
mutate(video_type = "genuine video") %>%
convert(chr(crt_q1, crt_q2, crt_q3, crt_q4, crt_q5, crt_q6, crt_q7))
raw_data_deepfaked_videos <- raw_data_deepfaked_videos %>%
mutate(video_type = "deepfake video") %>%
convert(chr(crt_q1, crt_q2, crt_q3, crt_q4, crt_q5, crt_q6, crt_q7))
raw_data_combined <- raw_data_genuine_videos %>%
full_join(raw_data_deepfaked_videos)
current_experiment_number <- 5
# Select out the demographic and method factor information
data_demographics_and_methods <- raw_data_combined %>%
group_by(subject) %>%
# Remove na values (note: this does not exclude participants)
summarise_all(funs(first(na.omit(.)))) %>%
mutate(condition_number = case_when(grepl("C1", condition) ~ 1,
grepl("C2", condition) ~ 2,
grepl("C3", condition) ~ 3,
grepl("C4", condition) ~ 4)) %>%
mutate(IAT_block_order = case_when(grepl("Incon B", condition) ~ "learning inconsistent block First",
grepl("Con B", condition) ~ "learning consistent block First")) %>%
mutate(experiment_condition = case_when(grepl("Positive_Video", condition) ~ "positive video",
grepl("Negative_Video", condition) ~ "negative video")) %>%
mutate(task_order = case_when(grepl("IAT_First", condition) ~ "iat first",
grepl("SR_First", condition) ~ "ratings first")) %>%
select(subject,
prolific_id,
video_type,
condition,
condition_number,
IAT_block_order,
experiment_condition,
task_order,
age,
gender,
gender_self_describe,
ethnicity,
ethnicity_self_describe,
education,
employment,
location,
income,
political_ideology_identity_1,
political_ideology_social_issues,
political_ideology_economic_issues,
religious_affiliation_general,
ras_q1,
ras_q2,
ras_q3,
ras_q4,
ras_q5,
ras_q6,
ras_q7,
ras_q8)
# select out the self-reported ratings and the participant id (subject)
data_self_reports <- raw_data_combined %>%
select(subject,
pos_neg,
good_bad,
like_dislike) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.)))) %>%
# create an average rating score
mutate(self_reported_rating = (pos_neg + good_bad + like_dislike)/3) %>%
mutate_if(is.numeric, round, digits = 2)
# Select and retain only the exploratory questions and participant id
data_exploratory_questions <- raw_data_combined %>%
select(subject,
memory_of_video_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
deepfake_video_check,
deepfake_concept_check,
issues_with_study) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.))))
# select out the self-reported ratings and the participant id (subject)
data_individual_differences <- raw_data_combined %>%
select(subject,
q1_bcti,
q2_bcti,
q3_bcti,
q4_bcti,
q5_bcti,
q6_bcti,
q7_bcti,
q8_bcti,
q9_bcti,
q10_bcti,
q11_bcti,
q12_bcti,
q13_bcti,
q14_bcti,
q15_bcti,
ocq_1,
ocq_2,
ocq_3,
ocq_4,
ocq_5,
ocq_6,
ocq_7,
ocq_8,
ocq_9,
ocq_10,
ocq_11,
ocq_12,
ocq_13,
ocq_14,
ocq_15,
ocq_16,
ocq_17,
ocq_18,
ocq_19,
ocq_20,
ocq_21,
ocq_22,
ocq_23,
ocq_24,
ocq_25,
ocq_26,
ocq_27,
ocq_28,
ocq_29,
ocq_30,
q1_rei,
q2_rei,
q3_rei,
q4_rei,
q5_rei,
q6_rei,
q7_rei,
q8_rei,
q9_rei,
q10_rei,
q11_rei,
q12_rei,
q13_rei,
q14_rei,
q15_rei,
q16_rei,
q17_rei,
q18_rei,
q19_rei,
q20_rei,
crt_q1,
crt_q2,
crt_q3,
crt_q4,
crt_q5,
crt_q6,
crt_q7,
crt_q8,
crt_q9) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.))))
data_iat_input <- raw_data_combined %>%
# Select and retain IAT related variables
select(subject,
name,
corr,
sender,
sender_id,
correct,
duration) %>%
# Select out only the data where the stimulus was shown
filter(sender == 'Stimulus') %>%
# Create a block and Trial column. Do so by renaming values from the 'sender_id' column to terms that the IAT script will work with (e.g., block 1,2,3,4,5,6,7)
separate(sender_id, into = c("temp_1", "temp_2", "temp_3", "block", "trial"), sep = "_") %>%
select(-temp_1, -temp_2, -temp_3) %>%
# Recode trial numbers so that they begin at 1 and run to 16 or 32
mutate(block = as.numeric(block),
trial = as.numeric(trial) + 1) %>%
rename(trial_number = trial) %>%
# Recode the TRUE/FALSE values from the correct column to 1,0
mutate(Correct = case_when(grepl("TRUE", correct) ~ 1,
grepl("FALSE", correct) ~ 0)) %>%
# Bring in the correct (i.e., Revised) Experimental Condition information from the Demographics File
full_join(data_demographics_and_methods, by = 'subject') %>%
# Recode block
# For participants in Conditions 1-2 the 'sender_id variable' corresponds to the following block order (this can be seen by inspecting the name and corr variables in the raw data):
# _3_0_0   = block 1 (Bob Chris)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 3 (Bob Bad Chris Good)
# _9_0_0   = block 4 (Bob Bad Chris Good)
# _11_0_0  = block 5 (Chris Bob)
# _13_0_0  = block 6 (Chris Bad Bob Good)
# _15_0_0  = block 7 (Chris Bad Bob Good)
# For participants in Conditions 3-4 the 'sender_id variable' corresponds to the following block order:
# _3_0_0   = block 5 (Chris Bob)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 6 (Chris Bad Bob Good)
# _9_0_0   = block 7 (Chris Bad Bob Good)
# _11_0_0  = block 1 (Bob Chris)
# _13_0_0  = block 3 (Bob Bad Chris Good)
# _15_0_0  = block 4 (Bob Bad Chris Good)
# Create a new variable (Revised block) and update the block numbering so that it is correct:
mutate(revised_block = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ 1,
block == 5 ~ 2,
block == 7 ~ 3,
block == 9 ~ 4,
block == 11 ~ 5,
block == 13 ~ 6,
block == 15 ~ 7),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ 5,
block == 5 ~ 2,
block == 7 ~ 6,
block == 9 ~ 7,
block == 11 ~ 1,
block == 13 ~ 3,
block == 15 ~ 4),NA))) %>%
#Select IAT related data
select(subject,
condition,
condition_number,
name,
corr,
trial_number,
block,
revised_block,
correct,
duration,
IAT_block_order)
# rename columns that IATscores package will use later on
data_iat_input <- data_iat_input %>%
mutate(experiment = current_experiment_number) %>%
select(subject,
trial_number,
block = revised_block,
correct,
latency = duration,
IAT_block_order,
condition,
condition_number)
# only retain the critical practice and test blocks (i.e., block_number = 3, 4, 6, 7)
data_iat_cleaned <- data_iat_input %>%
filter(block %in% c(3, 4, 6, 7)) %>%
# Create a new variable called Block_Type that indicates if a given block is a compatible or incompatible test block and if it is the first or second such block
# Participants in Condition 1, 2 received a positive video. Therefore blocks 3,4 are consistent with the video and blocks 6,7 are inconsistent with the video.
# Participants in Condition 3, 4 received a negative video. Therefore blocks 3,4 are inconsistent with the video and 6,7 are consistent with the video.
mutate(block_type = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ "compatibletest1",
block == 4 ~ "compatibletest2",
block == 6 ~ "incompatibletest1",
block == 7 ~ "incompatibletest2"),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ "incompatibletest1",
block == 4 ~ "incompatibletest2",
block == 6 ~ "compatibletest1",
block == 7 ~ "compatibletest2"),NA)))
data_iat_completeness <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(n = n()) %>%
mutate(complete_iat_data = case_when(n == 128 ~ "complete",
n > 128 ~ "excess",
n < 128 ~"partial")) %>%
ungroup() %>%
select(-n)
data_iat_completeness %>%
distinct(subject, .keep_all = TRUE) %>%
count(complete_iat_data) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
# exclude if total error rate > 30%
data_iat_accuracy_overall <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(iat_accuracy_overall = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_overall = ifelse(iat_accuracy_overall >= .70, TRUE, FALSE)) %>%
select(subject, passed_iat_accuracy_overall)
# exclude if error rate on any one block > 40%
data_iat_accuracy_by_block <- data_iat_cleaned %>%
group_by(subject, block) %>%
summarise(iat_accuracy_by_block = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_by_block = ifelse(iat_accuracy_by_block >= .60, TRUE, FALSE)) %>%
group_by(subject) %>%
summarise(passed_iat_accuracy_by_block = as.logical(min(passed_iat_accuracy_by_block))) %>%
ungroup()
data_iat_fast_responding <- data_iat_cleaned %>%
mutate(fast_response = ifelse(latency < 300, 1, 0)) %>%
group_by(subject) %>%
summarise(iat_percent_fast_responses = sum(fast_response)/n()) %>%
ungroup() %>%
mutate(passed_iat_percent_fast_responses = ifelse(iat_percent_fast_responses <= .10, TRUE, FALSE)) %>%
select(subject, passed_iat_percent_fast_responses)
data_iat_performance <- data_iat_accuracy_overall %>%
full_join(data_iat_accuracy_by_block, by = "subject") %>%
full_join(data_iat_fast_responding, by = "subject") %>%
rowwise() %>%
mutate(passed_iat_performance = as.logical(min(c(passed_iat_accuracy_overall,
passed_iat_accuracy_by_block,
passed_iat_percent_fast_responses), na.rm = TRUE))) %>%
ungroup() %>%
select(subject, passed_iat_performance)
rm(data_iat_accuracy_overall, data_iat_accuracy_by_block, data_iat_fast_responding)
data_iat_D2_scores <- data_iat_cleaned %>%
# rename and recode to create the input format that the IATscores package requires
mutate(praccrit = ifelse(block_type == "incompatibletest1" | block_type == "compatibletest1",
"prac", "crit"),
blockcode = ifelse(block_type == "incompatibletest1" | block_type == "incompatibletest2",
"incompatible_block", "compatible_block")) %>%
select(subject, subject, block, correct, latency, praccrit,  trial_number, block_type) %>%
mutate(blockcode = ifelse(block %in% c(3, 4), "pair1",
ifelse(block %in% c(6, 7), "pair2", NA)),
praccrit = ifelse(block %in% c(3, 6), "prac",
ifelse(block %in% c(4, 7), "crit", NA)))  %>%
filter(!is.na(blockcode)) %>%
# calculate D2 scores
# parameters are identical to those the package lists in the D2 wrapper function
IATscores::RobustScores(IATdata = .,
P1 = "fxtrim",  # Trim values < 400ms
P2 = "ignore",  # do not trim errors
P3 = "dscore",  # calculate d2 scores
P4 = "dist",    # distinguish between the prac and test blocks
verbose = FALSE,
autoremove = FALSE) %>%
rename(IAT_D2_score = p2112)
# Join all the files together for analyses
data_processed <- data_demographics_and_methods %>%
full_join(data_self_reports, by ='subject') %>%
full_join(data_iat_D2_scores, by='subject') %>%
full_join(data_exploratory_questions, by ='subject') %>%
full_join(data_individual_differences, by='subject') %>%
full_join(data_iat_completeness, by='subject') %>%
full_join(data_iat_performance, by='subject')
# Add in numeric ids for participants
unique_ids <- data_processed %>%
distinct(subject) %>%
rownames_to_column(var = "numeric_id") %>%
mutate(numeric_id = as.numeric(as.character(numeric_id)))
data_processed <- data_processed %>%
full_join(unique_ids, by = "subject")
# Order the columns for subsequent analyses
names(data_processed)
data_processed <- data_processed %>%
mutate(experiment = current_experiment_number) %>%
select(numeric_id,
#subject,
experiment,
age,
gender,
gender_self_describe,
ethnicity,
ethnicity_self_describe,
education,
employment,
location,
income,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
pos_neg,
good_bad,
like_dislike,
self_reported_rating,
IAT_D2_score,
memory_of_video_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
deepfake_video_check,
deepfake_concept_check,
issues_with_study,
political_ideology_identity_1,
political_ideology_social_issues,
political_ideology_economic_issues,
religious_affiliation_general,
ras_q1,
ras_q2,
ras_q3,
ras_q4,
ras_q5,
ras_q6,
ras_q7,
ras_q8,
q1_bcti,
q2_bcti,
q3_bcti,
q4_bcti,
q5_bcti,
q6_bcti,
q7_bcti,
q8_bcti,
q9_bcti,
q10_bcti,
q11_bcti,
q12_bcti,
q13_bcti,
q14_bcti,
q15_bcti,
ocq_1,
ocq_2,
ocq_3,
ocq_4,
ocq_5,
ocq_6,
ocq_7,
ocq_8,
ocq_9,
ocq_10,
ocq_11,
ocq_12,
ocq_13,
ocq_14,
ocq_15,
ocq_16,
ocq_17,
ocq_18,
ocq_19,
ocq_20,
ocq_21,
ocq_22,
ocq_23,
ocq_24,
ocq_25,
ocq_26,
ocq_27,
ocq_28,
ocq_29,
ocq_30,
q1_rei,
q2_rei,
q3_rei,
q4_rei,
q5_rei,
q6_rei,
q7_rei,
q8_rei,
q9_rei,
q10_rei,
q11_rei,
q12_rei,
q13_rei,
q14_rei,
q15_rei,
q16_rei,
q17_rei,
q18_rei,
q19_rei,
q20_rei,
crt_q1,
crt_q2,
crt_q3,
crt_q4,
crt_q5,
crt_q6,
crt_q7,
crt_q8,
crt_q9)
# Ensures that the processed data folder exists
dir.create("processed")
# write to disk
write_csv(data_processed, "processed/data_processed.csv")
data <- read_csv("processed/data_processed.csv")
View(data_processed)
