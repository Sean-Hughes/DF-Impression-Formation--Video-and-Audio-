# select out the self-reported ratings and the participant id (subject)
data_individual_differences <- raw_data_combined %>%
select(subject,
q1_bcti,
q2_bcti,
q3_bcti,
q4_bcti,
q5_bcti,
q6_bcti,
q7_bcti,
q8_bcti,
q9_bcti,
q10_bcti,
q11_bcti,
q12_bcti,
q13_bcti,
q14_bcti,
q15_bcti,
ocq_1,
ocq_2,
ocq_3,
ocq_4,
ocq_5,
ocq_6,
ocq_7,
ocq_8,
ocq_9,
ocq_10,
ocq_11,
ocq_12,
ocq_13,
ocq_14,
ocq_15,
ocq_16,
ocq_17,
ocq_18,
ocq_19,
ocq_20,
ocq_21,
ocq_22,
ocq_23,
ocq_24,
ocq_25,
ocq_26,
ocq_27,
ocq_28,
ocq_29,
ocq_30,
q1_rei,
q2_rei,
q3_rei,
q4_rei,
q5_rei,
q6_rei,
q7_rei,
q8_rei,
q9_rei,
q10_rei,
q11_rei,
q12_rei,
q13_rei,
q14_rei,
q15_rei,
q16_rei,
q17_rei,
q18_rei,
q19_rei,
q20_rei,
crt_q1,
crt_q2,
crt_q3,
crt_q4,
crt_q5,
crt_q6,
crt_q7,
crt_q8,
crt_q9) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.))))
data_iat_input <- raw_data_combined %>%
# Select and retain IAT related variables
select(subject,
name,
corr,
sender,
sender_id,
correct,
duration) %>%
# Select out only the data where the stimulus was shown
filter(sender == 'Stimulus') %>%
# Create a block and Trial column. Do so by renaming values from the 'sender_id' column to terms that the IAT script will work with (e.g., block 1,2,3,4,5,6,7)
separate(sender_id, into = c("temp_1", "temp_2", "temp_3", "block", "trial"), sep = "_") %>%
select(-temp_1, -temp_2, -temp_3) %>%
# Recode trial numbers so that they begin at 1 and run to 16 or 32
mutate(block = as.numeric(block),
trial = as.numeric(trial) + 1) %>%
rename(trial_number = trial) %>%
# Recode the TRUE/FALSE values from the correct column to 1,0
mutate(Correct = case_when(grepl("TRUE", correct) ~ 1,
grepl("FALSE", correct) ~ 0)) %>%
# Bring in the correct (i.e., Revised) Experimental Condition information from the Demographics File
full_join(data_demographics_and_methods, by = 'subject') %>%
# Recode block
# For participants in Conditions 1-2 the 'sender_id variable' corresponds to the following block order (this can be seen by inspecting the name and corr variables in the raw data):
# _3_0_0   = block 1 (Bob Chris)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 3 (Bob Bad Chris Good)
# _9_0_0   = block 4 (Bob Bad Chris Good)
# _11_0_0  = block 5 (Chris Bob)
# _13_0_0  = block 6 (Chris Bad Bob Good)
# _15_0_0  = block 7 (Chris Bad Bob Good)
# For participants in Conditions 3-4 the 'sender_id variable' corresponds to the following block order:
# _3_0_0   = block 5 (Chris Bob)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 6 (Chris Bad Bob Good)
# _9_0_0   = block 7 (Chris Bad Bob Good)
# _11_0_0  = block 1 (Bob Chris)
# _13_0_0  = block 3 (Bob Bad Chris Good)
# _15_0_0  = block 4 (Bob Bad Chris Good)
# Create a new variable (Revised block) and update the block numbering so that it is correct:
mutate(revised_block = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ 1,
block == 5 ~ 2,
block == 7 ~ 3,
block == 9 ~ 4,
block == 11 ~ 5,
block == 13 ~ 6,
block == 15 ~ 7),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ 5,
block == 5 ~ 2,
block == 7 ~ 6,
block == 9 ~ 7,
block == 11 ~ 1,
block == 13 ~ 3,
block == 15 ~ 4),NA))) %>%
#Select IAT related data
select(subject,
condition,
condition_number,
name,
corr,
trial_number,
block,
revised_block,
correct,
duration,
IAT_block_order)
# rename columns that IATscores package will use later on
data_iat_input <- data_iat_input %>%
mutate(experiment = current_experiment_number) %>%
select(subject,
trial_number,
block = revised_block,
correct,
latency = duration,
IAT_block_order,
condition,
condition_number)
# only retain the critical practice and test blocks (i.e., block_number = 3, 4, 6, 7)
data_iat_cleaned <- data_iat_input %>%
filter(block %in% c(3, 4, 6, 7)) %>%
# Create a new variable called Block_Type that indicates if a given block is a compatible or incompatible test block and if it is the first or second such block
# Participants in Condition 1, 2 received a positive video. Therefore blocks 3,4 are consistent with the video and blocks 6,7 are inconsistent with the video.
# Participants in Condition 3, 4 received a negative video. Therefore blocks 3,4 are inconsistent with the video and 6,7 are consistent with the video.
mutate(block_type = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ "compatibletest1",
block == 4 ~ "compatibletest2",
block == 6 ~ "incompatibletest1",
block == 7 ~ "incompatibletest2"),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ "incompatibletest1",
block == 4 ~ "incompatibletest2",
block == 6 ~ "compatibletest1",
block == 7 ~ "compatibletest2"),NA)))
data_iat_completeness <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(n = n()) %>%
mutate(complete_iat_data = case_when(n == 128 ~ "complete",
n > 128 ~ "excess",
n < 128 ~"partial")) %>%
ungroup() %>%
select(-n)
data_iat_completeness %>%
distinct(subject, .keep_all = TRUE) %>%
count(complete_iat_data) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
# exclude if total error rate > 30%
data_iat_accuracy_overall <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(iat_accuracy_overall = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_overall = ifelse(iat_accuracy_overall >= .70, TRUE, FALSE)) %>%
select(subject, passed_iat_accuracy_overall)
# exclude if error rate on any one block > 40%
data_iat_accuracy_by_block <- data_iat_cleaned %>%
group_by(subject, block) %>%
summarise(iat_accuracy_by_block = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_by_block = ifelse(iat_accuracy_by_block >= .60, TRUE, FALSE)) %>%
group_by(subject) %>%
summarise(passed_iat_accuracy_by_block = as.logical(min(passed_iat_accuracy_by_block))) %>%
ungroup()
data_iat_fast_responding <- data_iat_cleaned %>%
mutate(fast_response = ifelse(latency < 300, 1, 0)) %>%
group_by(subject) %>%
summarise(iat_percent_fast_responses = sum(fast_response)/n()) %>%
ungroup() %>%
mutate(passed_iat_percent_fast_responses = ifelse(iat_percent_fast_responses <= .10, TRUE, FALSE)) %>%
select(subject, passed_iat_percent_fast_responses)
data_iat_performance <- data_iat_accuracy_overall %>%
full_join(data_iat_accuracy_by_block, by = "subject") %>%
full_join(data_iat_fast_responding, by = "subject") %>%
rowwise() %>%
mutate(passed_iat_performance = as.logical(min(c(passed_iat_accuracy_overall,
passed_iat_accuracy_by_block,
passed_iat_percent_fast_responses), na.rm = TRUE))) %>%
ungroup() %>%
select(subject, passed_iat_performance)
rm(data_iat_accuracy_overall, data_iat_accuracy_by_block, data_iat_fast_responding)
data_iat_D2_scores <- data_iat_cleaned %>%
# rename and recode to create the input format that the IATscores package requires
mutate(praccrit = ifelse(block_type == "incompatibletest1" | block_type == "compatibletest1",
"prac", "crit"),
blockcode = ifelse(block_type == "incompatibletest1" | block_type == "incompatibletest2",
"incompatible_block", "compatible_block")) %>%
select(subject, subject, block, correct, latency, praccrit,  trial_number, block_type) %>%
mutate(blockcode = ifelse(block %in% c(3, 4), "pair1",
ifelse(block %in% c(6, 7), "pair2", NA)),
praccrit = ifelse(block %in% c(3, 6), "prac",
ifelse(block %in% c(4, 7), "crit", NA)))  %>%
filter(!is.na(blockcode)) %>%
# calculate D2 scores
# parameters are identical to those the package lists in the D2 wrapper function
IATscores::RobustScores(IATdata = .,
P1 = "fxtrim",  # Trim values < 400ms
P2 = "ignore",  # do not trim errors
P3 = "dscore",  # calculate d2 scores
P4 = "dist",    # distinguish between the prac and test blocks
verbose = FALSE,
autoremove = FALSE) %>%
rename(IAT_D2_score = p2112)
# Join all the files together for analyses
data_processed <- data_demographics_and_methods %>%
full_join(data_self_reports, by ='subject') %>%
full_join(data_iat_D2_scores, by='subject') %>%
full_join(data_exploratory_questions, by ='subject') %>%
full_join(data_individual_differences, by='subject') %>%
full_join(data_iat_completeness, by='subject') %>%
full_join(data_iat_performance, by='subject')
# Add in numeric ids for participants
unique_ids <- data_processed %>%
distinct(subject) %>%
rownames_to_column(var = "numeric_id") %>%
mutate(numeric_id = as.numeric(as.character(numeric_id)))
data_processed <- data_processed %>%
full_join(unique_ids, by = "subject")
# Order the columns for subsequent analyses
names(data_processed)
data_processed <- data_processed %>%
mutate(experiment = current_experiment_number) %>%
select(numeric_id,
#subject,
experiment,
age,
gender,
gender_self_describe,
ethnicity,
ethnicity_self_describe,
education,
employment,
location,
income,
condition,
experiment_condition,
video_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
pos_neg,
good_bad,
like_dislike,
self_reported_rating,
IAT_D2_score,
memory_of_video_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
deepfake_video_check,
deepfake_concept_check,
issues_with_study,
political_ideology_identity_1,
political_ideology_social_issues,
political_ideology_economic_issues,
religious_affiliation_general,
ras_q1,
ras_q2,
ras_q3,
ras_q4,
ras_q5,
ras_q6,
ras_q7,
ras_q8,
q1_bcti,
q2_bcti,
q3_bcti,
q4_bcti,
q5_bcti,
q6_bcti,
q7_bcti,
q8_bcti,
q9_bcti,
q10_bcti,
q11_bcti,
q12_bcti,
q13_bcti,
q14_bcti,
q15_bcti,
ocq_1,
ocq_2,
ocq_3,
ocq_4,
ocq_5,
ocq_6,
ocq_7,
ocq_8,
ocq_9,
ocq_10,
ocq_11,
ocq_12,
ocq_13,
ocq_14,
ocq_15,
ocq_16,
ocq_17,
ocq_18,
ocq_19,
ocq_20,
ocq_21,
ocq_22,
ocq_23,
ocq_24,
ocq_25,
ocq_26,
ocq_27,
ocq_28,
ocq_29,
ocq_30,
q1_rei,
q2_rei,
q3_rei,
q4_rei,
q5_rei,
q6_rei,
q7_rei,
q8_rei,
q9_rei,
q10_rei,
q11_rei,
q12_rei,
q13_rei,
q14_rei,
q15_rei,
q16_rei,
q17_rei,
q18_rei,
q19_rei,
q20_rei,
crt_q1,
crt_q2,
crt_q3,
crt_q4,
crt_q5,
crt_q6,
crt_q7,
crt_q8,
crt_q9)
# Ensures that the processed data folder exists
dir.create("processed")
# write to disk
write_csv(data_processed, "processed/data_processed.csv")
data <- read_csv("processed/data_processed.csv")
View(data_processed)
# dependencies -----
library(rstatix)
library(datarium)
library(tidyverse)
library(ggthemes)
library(knitr)
library(kableExtra)
library(broom)
library(effsize)
library(BayesFactor)
library(metafor)
library(ez)
library(schoRsch)
library(nnet)
library(epitools)
options(knitr.kable.NA = "/")
# Ensures that the processed data folder exists
dir.create("models")
dir.create("results")
# functions -----
# round p value using apa format
apa_p_value <- function(p){
p_formatted <- ifelse(p >= 0.0001, paste("=", round(p, 4)),
ifelse(p < 0.0001, "< .0001", NA))
p_formatted <- gsub(pattern = "0.", replacement = ".", x = p_formatted, fixed = TRUE)
p_formatted
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_cohens_d <- function(data){
require(effsize)
fit <- effsize::cohen.d(DV ~ IV, data = data)
results <- tibble(cohens_d = fit$estimate,
cohens_d_ci_lower = fit$conf.int["lower"],
cohens_d_ci_upper = fit$conf.int["upper"])
return(results)
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_ttest_bf <- function(data){
require(BayesFactor)
fit <- data %>%
ttestBF(formula = DV ~ IV, data = .)
results <- data.frame(bf10 = extractBF(fit)$bf)
return(results)
}
# full analysis workflow
# NB workflow returns mean_reference and mean_comparison, where reference is the first factor level and comparison is the next highest level.
analysis_workflow <- function(data){
# frequentist t test
results_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(broom::tidy(t.test(DV ~ IV, data = .))) %>%
ungroup() %>%
rename(t = statistic,
df = parameter,
p = p.value,
mean_reference = estimate1,
mean_comaprison = estimate2)
# cohens d
results_cohens_d <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_cohens_d(data = .)) %>%
ungroup()
# BF t test
results_bf_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_ttest_bf(data = .)) %>%
ungroup()
# combine
results <-
full_join(results_t_test,
results_cohens_d,
by = c("experiment", "DV_type")) %>%
full_join(results_bf_t_test,
by = c("experiment", "DV_type")) %>%
select(experiment, DV_type,
mean_reference, mean_comaprison,
t, df, p, cohens_d, cohens_d_ci_lower, cohens_d_ci_upper, bf10) %>%
mutate(reportable_result = paste0("M = ", round(mean_reference, 2), ", M = ", round(mean_comaprison, 2), ", t(", round(df, 2), ") = ", round(t, 2), ", p ", apa_p_value(p), ", d = ", round(cohens_d, 2), ", 95% CI [", round(cohens_d_ci_lower, 2), ", ", round(cohens_d_ci_upper, 2), "], BF10 = ", round(bf10, 1)))
return(results)
}
OR_to_d <- function(OR){
log(OR)*(sqrt(3)/pi)
}
# full data
data_processed <-
read_csv("C:/Users/Sean/Desktop/git/DF-Impression-Formation--Video-and-Audio-/Experiment 5/2. Data/processed/data_processed.csv")%>%
# set factor levels for t test comparisons
mutate(experiment_condition = fct_relevel(experiment_condition,
"positive video",
"negative video")) %>%
mutate(video_type = fct_relevel(video_type,
"genuine video",
"deepfake video")) %>%
# create exclusion variable for IAT data
mutate(exclude_iat = ifelse(complete_iat_data == "complete" & passed_iat_performance == TRUE,
FALSE, TRUE),
# if exclude variable is missing, then exclude
exclude_iat = ifelse(is.na(exclude_iat), TRUE, exclude_iat)) %>%
# create exclusion variable for missing exploratory question data
mutate(exclude_exploratory = ifelse(is.na(memory_of_video_content), TRUE,
ifelse(is.na(diagnosticity_question), TRUE,
ifelse(is.na(demand), TRUE,
ifelse(is.na(reactance), TRUE,
ifelse(is.na(hypothesis_awareness), TRUE,
ifelse(is.na(influence_awareness), TRUE, FALSE))))))) %>%
#create compound exclusion criteria
mutate(exclude = exclude_iat + exclude_exploratory)
# remove missing data
data_processed_after_exclusions <- data_processed %>%
filter(exclude == 0)
data_processed %>%
summarise(n = n(),
age_mean = mean(age, na.rm = TRUE),
age_sd = sd(age, na.rm = TRUE),
excluded_n = sum(exclude > 0),
excluded_percent = (excluded_n / n) *100) %>%
mutate_if(is.numeric, round, digits = 1) %>%
kable(align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
data_processed %>%
count(experiment, gender) %>%
spread(gender, n) %>%
kable(knitr.kable.NA = "/", align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
write_csv(data_processed_after_exclusions, "results/data_processed_after_exclusions.csv")
