---
title: "Experiment 4: analyses"
subtitle: "Analyses"
author: "Sean Hughes"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      warning=FALSE)
```

.libPaths()


# Dependencies & functions

```{r}

# dependencies -----
library(rstatix)
library(datarium)
library(tidyverse)
library(ggthemes)
library(knitr)
library(kableExtra)
library(broom)
library(effsize)
library(BayesFactor)
library(metafor)
library(ez)
library(schoRsch)
library(nnet)
library(epitools)

options(knitr.kable.NA = "/")

# Ensures that the processed data folder exists
dir.create("models")
dir.create("results")

# functions -----
# round p value using apa format
apa_p_value <- function(p){
  p_formatted <- ifelse(p >= 0.0001, paste("=", round(p, 4)),
                        ifelse(p < 0.0001, "< .0001", NA))
  p_formatted <- gsub(pattern = "0.", replacement = ".", x = p_formatted, fixed = TRUE)
  p_formatted
}

# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_cohens_d <- function(data){
  require(effsize)

  fit <- effsize::cohen.d(DV ~ IV, data = data)

  results <- tibble(cohens_d = fit$estimate,
                    cohens_d_ci_lower = fit$conf.int["lower"],
                    cohens_d_ci_upper = fit$conf.int["upper"])

  return(results)
}

# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_ttest_bf <- function(data){
  require(BayesFactor)

  fit <- data %>%
    ttestBF(formula = DV ~ IV, data = .)

  results <- data.frame(bf10 = extractBF(fit)$bf)
  return(results)
}


# full analysis workflow
# NB workflow returns mean_reference and mean_comparison, where reference is the first factor level and comparison is the next highest level.
analysis_workflow <- function(data){

  # frequentist t test
  results_t_test <- data %>%
    group_by(experiment, DV_type) %>%
    do(broom::tidy(t.test(DV ~ IV, data = .))) %>%
    ungroup() %>%
    rename(t = statistic,
           df = parameter,
           p = p.value,
           mean_reference = estimate1,
           mean_comaprison = estimate2)

  # cohens d
  results_cohens_d <- data %>%
    group_by(experiment, DV_type) %>%
    do(tidy_cohens_d(data = .)) %>%
    ungroup()

  # BF t test
  results_bf_t_test <- data %>%
    group_by(experiment, DV_type) %>%
    do(tidy_ttest_bf(data = .)) %>%
    ungroup()

  # combine
  results <-
    full_join(results_t_test,
              results_cohens_d,
              by = c("experiment", "DV_type")) %>%
    full_join(results_bf_t_test,
              by = c("experiment", "DV_type")) %>%
    select(experiment, DV_type,
           mean_reference, mean_comaprison,
           t, df, p, cohens_d, cohens_d_ci_lower, cohens_d_ci_upper, bf10) %>%
    mutate(reportable_result = paste0("M = ", round(mean_reference, 2), ", M = ", round(mean_comaprison, 2), ", t(", round(df, 2), ") = ", round(t, 2), ", p ", apa_p_value(p), ", d = ", round(cohens_d, 2), ", 95% CI [", round(cohens_d_ci_lower, 2), ", ", round(cohens_d_ci_upper, 2), "], BF10 = ", round(bf10, 1)))

  return(results)
}

OR_to_d <- function(OR){
  log(OR)*(sqrt(3)/pi)
}

```

# Data and exclusions

```{r}

# full data
data_processed <-
      read_xlsx("C:/Users/Sean/Desktop/git/DF-Impression-Formation--Video-and-Audio-/Experiment 4/2. Data/processed/data_hand_scored.xlsx")%>%
  # set factor levels for t test comparisons
  mutate(experiment_condition = fct_relevel(experiment_condition,
                                            "positive audio",
                                            "negative audio")) %>%
  mutate(audio_type = fct_relevel(audio_type,
                                            "genuine audio",
                                            "deepfake audio")) %>%
  
  # create exclusion variable for IAT data
  mutate(exclude_iat = ifelse(complete_iat_data == "complete" & passed_iat_performance == TRUE,
                          FALSE, TRUE),
         # if exclude variable is missing, then exclude
         exclude_iat = ifelse(is.na(exclude_iat), TRUE, exclude_iat)) %>%
  # create exclusion variable for missing exploratory question data 
  mutate(exclude_exploratory = ifelse(is.na(memory_of_audio_content), TRUE,
                                      ifelse(is.na(diagnosticity_question), TRUE,
                                             ifelse(is.na(demand), TRUE, 
                                                    ifelse(is.na(reactance), TRUE, 
                                                           ifelse(is.na(hypothesis_awareness), TRUE,
                                                                  ifelse(is.na(influence_awareness), TRUE, FALSE))))))) %>% 
  
  #create compound exclusion criteria
  mutate(exclude = exclude_iat + exclude_exploratory)
  
  # remove missing data
  data_processed_after_exclusions <- data_processed %>%
  filter(exclude == 0) 


```


# Data Transformations 

```{r}


# RECODE DEMAND: responses on the demand variable assigned a value of 0 (No Demand) or 1 (Demand)

data_processed_after_exclusions <- data_processed_after_exclusions %>%
  mutate(demand_recoded = case_when(grepl("No", demand) ~ 0,
                                    grepl("I", demand) ~ 0,
                                    grepl("Demand", demand) ~ 1)) 

# RECODE DIAGNOSTICITY: responses on the diagnostic variable are assigned a value from 0 (Not Diagnostic) to 3 (Strongly Diagnostic)

data_processed_after_exclusions <- data_processed_after_exclusions %>%
  mutate(diagnosticity_question_recoded = case_when(grepl("Not", diagnosticity_question) ~ 0,
                                       grepl("Slight", diagnosticity_question) ~ 1,
                                       grepl("Moderate", diagnosticity_question) ~ 2,
                                       grepl("Strong", diagnosticity_question) ~ 3))


# RECODE EVALUATIONS: Create two variables (self-report recoded and IAT recoded). An analytic aim (see sections below) is to compare genuine and deepfaked audio in terms of their effect sizes. However, in order to do this, we need to control for the valence of the audio themselves (some conditions got positive audio whereas others got negative audio). So the self-reported rating/IAT score * by -1 for those in the negative audio condition. This ensures that the negative and positive audio are being compared along the same dimension (strength) rather than valence, and that deepfake and genuine audio can be directly compared to one another

data_processed_after_exclusions <- data_processed_after_exclusions %>% 
  mutate(self_report_recoded = ifelse(experiment_condition == "negative audio", self_reported_rating * -1, self_reported_rating),
         IAT_recoded = ifelse(experiment_condition == "negative audio", IAT_D2_score * -1, IAT_D2_score))

# RECODE EXPLORATORY QUESTION CHECKS: responses on this variable assigned a value of 0 (Not Aware it was a Deepfake) or 1 (Aware it was a Deepfake)


data_processed_after_exclusions <- data_processed_after_exclusions %>%
  mutate(deepfake_check_recoded_ = case_when(grepl("Yes", deepfake_check_recoded) ~ 1,
                                                      grepl("No", deepfake_check_recoded) ~ 0)) %>%
  mutate(recognised_audio_manipulation_ = case_when(grepl("Yes", recognised_audio_manipulation) ~ 1,
                                                      grepl("No", recognised_audio_manipulation) ~ 0)) %>% 
  mutate(influence_awareness_recoded_ = case_when(grepl("Yes", influence_awareness_recoded) ~ 1,
                                                   grepl("No", influence_awareness_recoded) ~ 0)) %>% 
  mutate(hypothesis_awareness_recoded_ = case_when(grepl("Yes", hypothesis_awareness_recoded) ~ 1,
                                                   grepl("No", hypothesis_awareness_recoded) ~ 0))

# RECODE REACTANCE: responses on the reactance variable assigned a value of 0 (No Reactance) or 1 (Reactance)

data_processed_after_exclusions <- data_processed_after_exclusions %>%
  mutate(reactance_recoded = case_when(grepl("No", reactance) ~ 0,
                                    grepl("I", reactance) ~ 0,
                                    grepl("React", reactance) ~ 1))



# Order Variables in File for Later Analysis

data_processed_after_exclusions <- data_processed_after_exclusions %>%
  mutate(demographic_items = "*",
          method_items = "*",
          evaluative_items = "*",
          exploratory_items = "*",
          individual_difference_items = "*") %>%
  select(numeric_id,
         experiment,
         demographic_items,
         age,
         gender,
         method_items,
         condition,
         experiment_condition,
         audio_type,
         task_order,
         IAT_block_order,
         complete_iat_data,
         passed_iat_performance,
         exclude_iat,
         exclude_exploratory,
         exclude,
         evaluative_items,
         pos_neg,
         good_bad,
         like_dislike,
         self_reported_rating,
         self_report_recoded,
         IAT_D2_score,
         IAT_recoded,
         exploratory_items,
         memory_of_audio_content,
         diagnosticity_question,
         diagnosticity_question_recoded,
         demand,
         demand_recoded,
         reactance,
         reactance_recoded,
         hypothesis_awareness,
         hypothesis_awareness_recoded,
         hypothesis_awareness_recoded_,
         influence_awareness,
         influence_awareness_recoded,
         influence_awareness_recoded_,
         recognised_audio_manipulation,
         recognised_audio_manipulation_,
         deepfake_check,
         deepfake_check_recoded,
         deepfake_check_recoded_,
         issues_with_study)


  # Write total dataset after exclusions to file
  write_csv(data_processed_after_exclusions, "results/total_data.csv")
  
  # Write deepfake only condition after exclusions to file
  data_deepfake_condition <- data_processed_after_exclusions %>%
  filter(audio_type == "deepfake audio") %>%
  write_csv("results/deepfake_only.csv")

# Write genuine only condition after exclusions to file
  data_genuine_condition <- data_processed_after_exclusions %>%
  filter(audio_type == "genuine audio") %>%
  write_csv("results/genuine_only.csv")
  
```


# Demographics

```{r}

data_processed %>%
  summarise(n = n(),
            age_mean = mean(age, na.rm = TRUE),
            age_sd = sd(age, na.rm = TRUE),
            excluded_n = sum(exclude > 0),
            excluded_percent = (excluded_n / n) *100) %>%
  mutate_if(is.numeric, round, digits = 1) %>%
  kable(align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_processed %>%
  count(experiment, gender) %>%
  spread(gender, n) %>%
  kable(knitr.kable.NA = "/", align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)


```

# Analyses

## 1. Did evaluations differ as a function of audio content (positive vs. negative statements)?

### IAT & self_reports

- by DV

```{r}

results_iat_selfreports_audio_content <- data_processed_after_exclusions %>%
  rename(IV = experiment_condition) %>%
  gather(DV_type, DV, c(self_reported_rating, IAT_D2_score)) %>%
  select(experiment, DV_type, DV, IV) %>%
  drop_na() %>%
  analysis_workflow(data = .)

write_csv(results_iat_selfreports_audio_content, "results/results_iat_selfreports_audio_content.csv")

results_iat_selfreports_audio_content %>%
  select(experiment, DV_type, reportable_result) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)


ratings_plot <- data_processed_after_exclusions %>%
  group_by(experiment_condition) %>%
  dplyr::summarise(mean_rating = mean(self_reported_rating, na.rm = TRUE),
                   se_rating = sd(self_reported_rating)/sqrt(length(self_reported_rating)), na.rm = TRUE) %>%
  ungroup() 

ggplot(ratings_plot, aes(x=experiment_condition, y=mean_rating, group = 1)) + 
    geom_errorbar(aes(ymin=mean_rating-se_rating, ymax=mean_rating+se_rating), width=.1) +
    geom_line() +
    geom_point()+
   theme_classic() +
  ylim(-3, 3)

IAT_plot <- data_processed_after_exclusions %>%
  group_by(experiment_condition) %>%
  dplyr::summarise(mean_IAT = mean(IAT_D2_score, na.rm = TRUE),
                   se_IAT = sd(IAT_D2_score)/sqrt(length(IAT_D2_score)), na.rm = TRUE) %>%
  ungroup() 

ggplot(IAT_plot, aes(x=experiment_condition, y=mean_IAT, group = 1)) + 
    geom_errorbar(aes(ymin=mean_IAT-se_IAT, ymax=mean_IAT+se_IAT), width=.1) +
    geom_line() +
    geom_point()+
   theme_classic() +
  ylim(-1, 1)


```


## 2. Did evaluations differ as a function of audio type (genuine vs. deepfaked)?

### IAT & self_reports

- by DV

```{r}

results_iat_selfreports_audio_type <- data_processed_after_exclusions %>%
  rename(IV = audio_type) %>%
  gather(DV_type, DV, c(self_reported_rating, IAT_D2_score)) %>%
  select(experiment, DV_type, DV, IV) %>%
  drop_na() %>%
  analysis_workflow(data = .)

write_csv(results_iat_selfreports_audio_type, "results/results_iat_selfreports_audio_type.csv")

results_iat_selfreports_audio_type %>%
  select(experiment, DV_type, reportable_result) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```


## 3. Does the strength of evaluation depend on audio content (e.g., do positive audio give rise to stronger effects than negative audio)?

### IAT & self_reports

- by DV


```{r}

# Firs recode the self-reported ratings in order to compare positive and negative audio along the same scale. Do this by * the self-reported rating score by -1 for those in the negative audio condition. This ensures that the negative and positive audio are being compared along the same dimension (strength) rather than valence

data_processed_after_exclusions <- data_processed_after_exclusions %>% 
  mutate(self_report_recoded = ifelse(experiment_condition == "negative audio", self_reported_rating * -1, self_reported_rating),
         IAT_recoded = ifelse(experiment_condition == "negative audio", IAT_D2_score * -1, IAT_D2_score))

write_csv(data_processed_after_exclusions, "results/data_with_recoding.csv")

sean <- data_processed_after_exclusions %>% 
  filter(audio_type == "deepfake audio")

write_csv(sean, "results/data_deepfake_only.csv")

results_iat_selfreports_evaluation_strength <- data_processed_after_exclusions %>%
  rename(IV = audio_type) %>%
  gather(DV_type, DV, c(self_report_recoded, IAT_recoded)) %>%
  select(experiment, DV_type, DV, IV) %>%
  drop_na() %>%
  analysis_workflow(data = .)

write_csv(results_iat_selfreports_evaluation_strength, "results/results_iat_selfreports_evaluation_strength.csv")

results_iat_selfreports_evaluation_strength %>%
  select(experiment, DV_type, reportable_result) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```

## 4. Is there an interaction between audio content and audio type? 

```{r}

# inspect the four experimental conditions 
data_processed_after_exclusions %>% sample_n_by(experiment_condition, audio_type, size = 1)

# get summary stats for the four experimental conditions

data_processed_after_exclusions %>%
  group_by(experiment_condition, audio_type) %>%
  get_summary_stats(self_reported_rating, type = "mean_sd")

# Run the two way ANOVA on audio type and content

results_audio_type_audio_content <- data_processed_after_exclusions %>% anova_test(self_reported_rating ~ experiment_condition * audio_type)

results_audio_type_audio_content

```


