information_preserved <- function(x, length) {
return(
count_unique(str_sub(x, end=i)) ==
count_unique(x)
)
}
# used to extract the JSON data
parseJSON <- function(input) {
return(input %>%
fromJSON(flatten=T) %>% {
# Coerce lists
if (class(.) == 'list') {
discard(., is.null) %>%
as_tibble()
} else {
.
} } %>%
# Sanitize names
janitor::clean_names() %>%
# Use only strings for now, and re-encode types later
mutate_all(as.character))
}
# 'Connect' to database
connection <- dbConnect(
drv=RSQLite::SQLite(),
dbname= "raw/Experiment_4_Genuine_data.sqlite")
# Extract main table
database_genuine_audio <- dbGetQuery(
conn=connection,
statement='SELECT * FROM labjs')
# Close connection
dbDisconnect(
conn=connection)
# Discard connection
rm(connection)
database_genuine_audio_meta_data <- map_dfr(database_genuine_audio$metadata, fromJSON) %>%
dplyr::rename(observation = id)
database_genuine_audio <- database_genuine_audio %>%
bind_cols(database_genuine_audio_meta_data) %>%
# Remove metadata column
select(-metadata)
# Remove temporary data frame
rm(database_genuine_audio_meta_data)
# Reduce the length of the random id variable to five characters (this is a sufficient length to identify each unique participant)
for (i in 5:36) {
if (
information_preserved(database_genuine_audio$session, i) &&
information_preserved(database_genuine_audio$observation, i)
) {
break()
}
}
database_genuine_audio <- database_genuine_audio %>%
dplyr::mutate(
session=str_sub(session, end=i),
observation=str_sub(observation, end=i))
rm(i, count_unique, information_preserved)
database_genuine_audio_full <- database_genuine_audio %>%
dplyr::filter(payload == 'full')
if (nrow(database_genuine_audio_full) > 0) {
database_genuine_audio_full %>%
group_by(observation, id) %>%
do(
{ map_dfr(.$data, parseJSON) } %>%
bind_rows()
) %>%
ungroup() %>%
select(-id) -> database_genuine_audio_full
}
database_genuine_audio %>%
dplyr::filter(payload %in% c('incremental', 'latest')) %>%
group_by(observation, id) %>%
do(
{ map_dfr(.$data, parseJSON) } %>%
bind_rows()
) %>%
ungroup() %>%
select(-id) -> database_genuine_audio_incremental
gc()
##Merge data sets
#For analysis, we'll use the full data sets where available, and incremental data when it is the the only information we have for a user.
raw_data_genuine_audio <- database_genuine_audio_full %>%
bind_rows(
database_genuine_audio_incremental %>%
filter(!(observation %in% database_genuine_audio_full$observation))) %>%
type_convert()
gc()
# rename the observation column to subject
raw_data_genuine_audio <- raw_data_genuine_audio %>%
rename(subject = observation)
# Ensures that all cells contain the same value even if only a subset of those cells is currently filled
raw_data_genuine_audio %>%
group_by(subject) %>%
fill(matches('code'), .direction='down') %>%
fill(matches('code'), .direction='up') %>%
ungroup() -> raw_data_genuine_audio
rm(database_genuine_audio, database_genuine_audio_full, database_genuine_audio_incremental)
# Create  a backup of the data while I am writing the script so I don't have to work with the database which takes a bunch of time
Raw_Data_genuine <- raw_data_genuine_audio
current_experiment_number <- 4
# Select out the demographic and method factor information
data_demographics_and_methods <- raw_data_genuine_audio %>%
select(subject,
audio_type,
prolific_id,
age,
gender,
condition,
name) %>%
group_by(subject) %>%
# Remove na values (note: this does not exclude participants)
summarise_all(funs(first(na.omit(.)))) %>%
mutate(condition_number = case_when(grepl("C1", condition) ~ 1,
grepl("C2", condition) ~ 2,
grepl("C3", condition) ~ 3,
grepl("C4", condition) ~ 4)) %>%
mutate(IAT_block_order = case_when(grepl("Incon B", condition) ~ "learning inconsistent block First",
grepl("Con B", condition) ~ "learning consistent block First")) %>%
mutate(experiment_condition = case_when(grepl("Positive_Audio", condition) ~ "positive audio",
grepl("Negative_Audio", condition) ~ "negative audio")) %>%
mutate(task_order = case_when(grepl("IAT_First", condition) ~ "iat first",
grepl("SR_First", condition) ~ "ratings first"))
View(raw_data_genuine_audio)
raw_data_genuine_audio <- raw_data_genuine_audio %>%
mutate(audio_type = "genuine audio")
current_experiment_number <- 4
# Select out the demographic and method factor information
data_demographics_and_methods <- raw_data_genuine_audio %>%
select(subject,
audio_type,
prolific_id,
age,
gender,
condition,
name) %>%
group_by(subject) %>%
# Remove na values (note: this does not exclude participants)
summarise_all(funs(first(na.omit(.)))) %>%
mutate(condition_number = case_when(grepl("C1", condition) ~ 1,
grepl("C2", condition) ~ 2,
grepl("C3", condition) ~ 3,
grepl("C4", condition) ~ 4)) %>%
mutate(IAT_block_order = case_when(grepl("Incon B", condition) ~ "learning inconsistent block First",
grepl("Con B", condition) ~ "learning consistent block First")) %>%
mutate(experiment_condition = case_when(grepl("Positive_Audio", condition) ~ "positive audio",
grepl("Negative_Audio", condition) ~ "negative audio")) %>%
mutate(task_order = case_when(grepl("IAT_First", condition) ~ "iat first",
grepl("SR_First", condition) ~ "ratings first"))
# select out the self-reported ratings and the participant id (subject)
data_self_reports <- raw_data_genuine_audio %>%
select(subject,
pos_neg,
good_bad,
like_dislike) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.)))) %>%
# create an average rating score
mutate(self_reported_rating = (pos_neg + good_bad + like_dislike)/3) %>%
mutate_if(is.numeric, round, digits = 2)
# Select and retain only the exploratory questions and participant id
data_exploratory_questions <- raw_data_genuine_audio %>%
select(subject,
memory_of_audio_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
issues_with_study) %>%
group_by(subject) %>%
summarise_all(funs(first(na.omit(.))))
data_iat_input <- raw_data_genuine_audio %>%
# Select and retain IAT related variables
select(subject,
name,
corr,
sender,
sender_id,
correct,
duration) %>%
# Select out only the data where the stimulus was shown
filter(sender == 'Stimulus') %>%
# Create a block and Trial column. Do so by renaming values from the 'sender_id' column to terms that the IAT script will work with (e.g., block 1,2,3,4,5,6,7)
separate(sender_id, into = c("temp_1", "temp_2", "temp_3", "block", "trial"), sep = "_") %>%
select(-temp_1, -temp_2, -temp_3) %>%
# Recode trial numbers so that they begin at 1 and run to 16 or 32
mutate(block = as.numeric(block),
trial = as.numeric(trial) + 1) %>%
rename(trial_number = trial) %>%
# Recode the TRUE/FALSE values from the correct column to 1,0
mutate(Correct = case_when(grepl("TRUE", correct) ~ 1,
grepl("FALSE", correct) ~ 0)) %>%
# Bring in the correct (i.e., Revised) Experimental Condition information from the Demographics File
full_join(data_demographics_and_methods, by = 'subject') %>%
# Recode block
# For participants in Conditions 1-2 the 'sender_id variable' corresponds to the following block order (this can be seen by inspecting the name and corr variables in the raw data):
# _3_0_0   = block 1 (Bob Chris)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 3 (Bob Bad Chris Good)
# _9_0_0   = block 4 (Bob Bad Chris Good)
# _11_0_0  = block 5 (Chris Bob)
# _13_0_0  = block 6 (Chris Bad Bob Good)
# _15_0_0  = block 7 (Chris Bad Bob Good)
# For participants in Conditions 3-4 the 'sender_id variable' corresponds to the following block order:
# _3_0_0   = block 5 (Chris Bob)
# _5_0_0   = block 2 (Bad Good)
# _7_0_0   = block 6 (Chris Bad Bob Good)
# _9_0_0   = block 7 (Chris Bad Bob Good)
# _11_0_0  = block 1 (Bob Chris)
# _13_0_0  = block 3 (Bob Bad Chris Good)
# _15_0_0  = block 4 (Bob Bad Chris Good)
# Create a new variable (Revised block) and update the block numbering so that it is correct:
mutate(revised_block = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ 1,
block == 5 ~ 2,
block == 7 ~ 3,
block == 9 ~ 4,
block == 11 ~ 5,
block == 13 ~ 6,
block == 15 ~ 7),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ 5,
block == 5 ~ 2,
block == 7 ~ 6,
block == 9 ~ 7,
block == 11 ~ 1,
block == 13 ~ 3,
block == 15 ~ 4),NA))) %>%
#Select IAT related data
select(subject,
condition,
condition_number,
name = name.x,
corr,
trial_number,
block,
revised_block,
correct,
duration,
IAT_block_order)
# rename columns that IATscores package will use later on
data_iat_input <- data_iat_input %>%
mutate(experiment = current_experiment_number) %>%
select(subject,
trial_number,
block = revised_block,
correct,
latency = duration,
IAT_block_order,
condition,
condition_number)
# only retain the critical practice and test blocks (i.e., block_number = 3, 4, 6, 7)
data_iat_cleaned <- data_iat_input %>%
filter(block %in% c(3, 4, 6, 7)) %>%
# Create a new variable called Block_Type that indicates if a given block is a compatible or incompatible test block and if it is the first or second such block
# Participants in Condition 1, 2 received a positive audio. Therefore blocks 3,4 are consistent with the audio and blocks 6,7 are inconsistent with the audio.
# Participants in Condition 3, 4 received a negative audio. Therefore blocks 3,4 are inconsistent with the audio and 6,7 are consistent with the audio.
mutate(block_type = ifelse(condition_number %in% c(1, 2),
case_when(block == 3 ~ "compatibletest1",
block == 4 ~ "compatibletest2",
block == 6 ~ "incompatibletest1",
block == 7 ~ "incompatibletest2"),
ifelse(condition_number %in% c(3, 4),
case_when(block == 3 ~ "incompatibletest1",
block == 4 ~ "incompatibletest2",
block == 6 ~ "compatibletest1",
block == 7 ~ "compatibletest2"),NA)))
data_iat_completeness <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(n = n()) %>%
mutate(complete_iat_data = case_when(n == 128 ~ "complete",
n > 128 ~ "excess",
n < 128 ~"partial")) %>%
ungroup() %>%
select(-n)
data_iat_completeness %>%
distinct(subject, .keep_all = TRUE) %>%
count(complete_iat_data) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
# exclude if total error rate > 30%
data_iat_accuracy_overall <- data_iat_cleaned %>%
group_by(subject) %>%
summarise(iat_accuracy_overall = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_overall = ifelse(iat_accuracy_overall >= .70, TRUE, FALSE)) %>%
select(subject, passed_iat_accuracy_overall)
# exclude if error rate on any one block > 40%
data_iat_accuracy_by_block <- data_iat_cleaned %>%
group_by(subject, block) %>%
summarise(iat_accuracy_by_block = sum(correct)/n()) %>%
ungroup() %>%
mutate(passed_iat_accuracy_by_block = ifelse(iat_accuracy_by_block >= .60, TRUE, FALSE)) %>%
group_by(subject) %>%
summarise(passed_iat_accuracy_by_block = as.logical(min(passed_iat_accuracy_by_block))) %>%
ungroup()
data_iat_fast_responding <- data_iat_cleaned %>%
mutate(fast_response = ifelse(latency < 300, 1, 0)) %>%
group_by(subject) %>%
summarise(iat_percent_fast_responses = sum(fast_response)/n()) %>%
ungroup() %>%
mutate(passed_iat_percent_fast_responses = ifelse(iat_percent_fast_responses <= .10, TRUE, FALSE)) %>%
select(subject, passed_iat_percent_fast_responses)
data_iat_performance <- data_iat_accuracy_overall %>%
full_join(data_iat_accuracy_by_block, by = "subject") %>%
full_join(data_iat_fast_responding, by = "subject") %>%
rowwise() %>%
mutate(passed_iat_performance = as.logical(min(c(passed_iat_accuracy_overall,
passed_iat_accuracy_by_block,
passed_iat_percent_fast_responses), na.rm = TRUE))) %>%
ungroup() %>%
select(subject, passed_iat_performance)
rm(data_iat_accuracy_overall, data_iat_accuracy_by_block, data_iat_fast_responding)
data_iat_D2_scores <- data_iat_cleaned %>%
# rename and recode to create the input format that the IATscores package requires
mutate(praccrit = ifelse(block_type == "incompatibletest1" | block_type == "compatibletest1",
"prac", "crit"),
blockcode = ifelse(block_type == "incompatibletest1" | block_type == "incompatibletest2",
"incompatible_block", "compatible_block")) %>%
select(subject, subject, block, correct, latency, praccrit,  trial_number, block_type) %>%
mutate(blockcode = ifelse(block %in% c(3, 4), "pair1",
ifelse(block %in% c(6, 7), "pair2", NA)),
praccrit = ifelse(block %in% c(3, 6), "prac",
ifelse(block %in% c(4, 7), "crit", NA)))  %>%
filter(!is.na(blockcode)) %>%
# calculate D2 scores
# parameters are identical to those the package lists in the D2 wrapper function
IATscores::RobustScores(IATdata = .,
P1 = "fxtrim",  # Trim values < 400ms
P2 = "ignore",  # do not trim errors
P3 = "dscore",  # calculate d2 scores
P4 = "dist",    # distinguish between the prac and test blocks
verbose = FALSE,
autoremove = FALSE) %>%
rename(IAT_D2_score = p2112)
# Join all the files together for analyses
data_processed <- data_demographics_and_methods %>%
full_join(data_self_reports, by ='subject') %>%
full_join(data_exploratory_questions, by ='subject') %>%
full_join(data_iat_D2_scores, by='subject') %>%
full_join(data_iat_completeness, by='subject') %>%
full_join(data_iat_performance, by='subject')
# Add in numeric ids for participants
unique_ids <- data_processed %>%
distinct(subject) %>%
rownames_to_column(var = "numeric_id") %>%
mutate(numeric_id = as.numeric(as.character(numeric_id)))
data_processed <- data_processed %>%
full_join(unique_ids, by = "subject")
# Order the columns for subsequent analyses
data_processed <- data_processed %>%
mutate(experiment = current_experiment_number) %>%
select(numeric_id,
#subject,
experiment,
gender,
age,
condition,
experiment_condition,
audio_type,
task_order,
IAT_block_order,
complete_iat_data,
passed_iat_performance,
pos_neg,
good_bad,
like_dislike,
self_reported_rating,
IAT_D2_score,
memory_of_audio_content,
diagnosticity_question,
demand,
reactance,
hypothesis_awareness,
influence_awareness,
issues_with_study)
# Ensures that the processed data folder exists
dir.create("processed")
# write to disk
write_csv(data_processed, "processed/data_processed.csv")
data <- read_csv("processed/data_processed.csv")
# dependencies -----
library(rstatix)
library(datarium)
library(tidyverse)
library(ggthemes)
library(knitr)
library(kableExtra)
library(broom)
library(effsize)
library(BayesFactor)
library(metafor)
library(ez)
library(schoRsch)
library(nnet)
library(epitools)
options(knitr.kable.NA = "/")
# Ensures that the processed data folder exists
dir.create("models")
dir.create("results")
# functions -----
# round p value using apa format
apa_p_value <- function(p){
p_formatted <- ifelse(p >= 0.0001, paste("=", round(p, 4)),
ifelse(p < 0.0001, "< .0001", NA))
p_formatted <- gsub(pattern = "0.", replacement = ".", x = p_formatted, fixed = TRUE)
p_formatted
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_cohens_d <- function(data){
require(effsize)
fit <- effsize::cohen.d(DV ~ IV, data = data)
results <- tibble(cohens_d = fit$estimate,
cohens_d_ci_lower = fit$conf.int["lower"],
cohens_d_ci_upper = fit$conf.int["upper"])
return(results)
}
# calculate cohens d and return its output in tidy format - a helper function for analysis_workflow
tidy_ttest_bf <- function(data){
require(BayesFactor)
fit <- data %>%
ttestBF(formula = DV ~ IV, data = .)
results <- data.frame(bf10 = extractBF(fit)$bf)
return(results)
}
# full analysis workflow
# NB workflow returns mean_reference and mean_comparison, where reference is the first factor level and comparison is the next highest level.
analysis_workflow <- function(data){
# frequentist t test
results_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(broom::tidy(t.test(DV ~ IV, data = .))) %>%
ungroup() %>%
rename(t = statistic,
df = parameter,
p = p.value,
mean_reference = estimate1,
mean_comaprison = estimate2)
# cohens d
results_cohens_d <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_cohens_d(data = .)) %>%
ungroup()
# BF t test
results_bf_t_test <- data %>%
group_by(experiment, DV_type) %>%
do(tidy_ttest_bf(data = .)) %>%
ungroup()
# combine
results <-
full_join(results_t_test,
results_cohens_d,
by = c("experiment", "DV_type")) %>%
full_join(results_bf_t_test,
by = c("experiment", "DV_type")) %>%
select(experiment, DV_type,
mean_reference, mean_comaprison,
t, df, p, cohens_d, cohens_d_ci_lower, cohens_d_ci_upper, bf10) %>%
mutate(reportable_result = paste0("M = ", round(mean_reference, 2), ", M = ", round(mean_comaprison, 2), ", t(", round(df, 2), ") = ", round(t, 2), ", p ", apa_p_value(p), ", d = ", round(cohens_d, 2), ", 95% CI [", round(cohens_d_ci_lower, 2), ", ", round(cohens_d_ci_upper, 2), "], BF10 = ", round(bf10, 1)))
return(results)
}
OR_to_d <- function(OR){
log(OR)*(sqrt(3)/pi)
}
# full data
data_processed <-
read_csv("C:/Users/Sean/Desktop/git/Deepfaking/Experiment 4/2. Data/processed/data_processed.csv") %>%
# set factor levels for t test comparisons
mutate(experiment_condition = fct_relevel(experiment_condition,
"positive audio",
"negative audio")) %>%
mutate(audio_type = fct_relevel(audio_type,
"genuine audio",
"deepfake audio")) %>%
# create exclusion variable for IAT data
mutate(exclude_iat = ifelse(complete_iat_data == "complete" & passed_iat_performance == TRUE,
FALSE, TRUE),
# if exclude variable is missing, then exclude
exclude_iat = ifelse(is.na(exclude_iat), TRUE, exclude_iat)) %>%
# create exclusion variable for missing exploratory question data
mutate(exclude_exploratory = ifelse(is.na(memory_of_audio_content), TRUE,
ifelse(is.na(diagnosticity_question), TRUE,
ifelse(is.na(demand), TRUE,
ifelse(is.na(reactance), TRUE,
ifelse(is.na(hypothesis_awareness), TRUE,
ifelse(is.na(influence_awareness), TRUE, FALSE))))))) %>%
#create compound exclusion criteria
mutate(exclude = exclude_iat + exclude_exploratory)
# remove missing data
data_processed_after_exclusions <- data_processed %>%
filter(exclude == 0)
data_processed %>%
summarise(n = n(),
age_mean = mean(age, na.rm = TRUE),
age_sd = sd(age, na.rm = TRUE),
excluded_n = sum(exclude > 0),
excluded_percent = (excluded_n / n) *100) %>%
mutate_if(is.numeric, round, digits = 1) %>%
kable(align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
data_processed %>%
count(experiment, gender) %>%
spread(gender, n) %>%
kable(knitr.kable.NA = "/", align = "c") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)
write_csv(data_processed_after_exclusions, "results/data_processed_after_exclusions.csv")
results_iat_selfreports_audio_content <- data_processed_after_exclusions %>%
rename(IV = experiment_condition) %>%
gather(DV_type, DV, c(self_reported_rating, IAT_D2_score)) %>%
select(experiment, DV_type, DV, IV) %>%
drop_na() %>%
analysis_workflow(data = .)
